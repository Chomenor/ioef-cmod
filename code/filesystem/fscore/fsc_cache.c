/*
===========================================================================
Copyright (C) 2017 Noah Metzger (chomenor@gmail.com)

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Quake III Arena source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/

#ifdef NEW_FILESYSTEM
#include "fscore.h"

#define STACKPTR_SRC(pointer) ( fsc_stack_retrieve(&xw->source_fs->general_stack, pointer) )

/* ******************************************************************************** */
// Support Structures
/* ******************************************************************************** */

typedef struct {
	fsc_filesystem_t *source_fs;

	// Temporary - not written to file
	fsc_stack_t filemap_stack;
	fsc_hashtable_t filemap;

	// Generated by various export functions
	fsc_stack_t export_stack;
	fsc_hashtable_t export_string_repository;

	// Generated by fscache_export_filesystem
	fsc_hashtable_t export_files;
	fsc_hashtable_t export_directories;

	// Generated by fscache_export_shaders
	fsc_hashtable_t export_shaders;

	// Generated by fscache_export_crosshairs
	fsc_hashtable_t export_crosshairs;

	// Generated by fscache_build_pk3_hash_lookup
	fsc_hashtable_t export_pk3_hash_lookup;
} export_work_t;

typedef struct {
	// Hash table compliance
	fsc_hashtable_entry_t hte;

	fsc_stackptr_t source_file_ptr;
	fsc_stackptr_t export_file_ptr;
} filemap_entry_t;

/* ******************************************************************************** */
// Data Building
/* ******************************************************************************** */

unsigned int integer_hash(unsigned int value) {
	return value; }

fsc_stackptr_t convert_string(fsc_stackptr_t source_string, export_work_t *xw) {
	// Converts a string from the standard string repository to the export repository
	if(!source_string) return 0;
	return fsc_string_repository_getstring(STACKPTR_SRC(source_string), 1, &xw->export_string_repository, &xw->export_stack); }

fsc_stackptr_t file_map_lookup(fsc_stackptr_t source_file_ptr, export_work_t *xw) {
	// Converts stackptr in general stack to stackptr in export stack
	unsigned int hash = integer_hash(source_file_ptr);
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t filemap_entry_ptr;
	filemap_entry_t *filemap_entry;

	fsc_hashtable_open(&xw->filemap, hash, &hti);
	while((filemap_entry_ptr = fsc_hashtable_next(&hti))) {
		filemap_entry = fsc_stack_retrieve(&xw->filemap_stack, filemap_entry_ptr);
		if(filemap_entry->source_file_ptr == source_file_ptr) return filemap_entry->export_file_ptr; }

	return 0; }

void file_map_insert(fsc_stackptr_t source_file_ptr, fsc_stackptr_t export_file_ptr, export_work_t *xw) {
	unsigned int hash = integer_hash(source_file_ptr);
	fsc_stackptr_t filemap_entry_ptr;
	filemap_entry_t *filemap_entry;

	filemap_entry_ptr = fsc_stack_allocate(&xw->filemap_stack, sizeof(filemap_entry_t));
	filemap_entry = fsc_stack_retrieve(&xw->filemap_stack, filemap_entry_ptr);

	filemap_entry->source_file_ptr = source_file_ptr;
	filemap_entry->export_file_ptr = export_file_ptr;
	fsc_hashtable_insert(filemap_entry_ptr, hash, &xw->filemap); }

fsc_stackptr_t convert_file(fsc_stackptr_t source_file_ptr, export_work_t *xw) {
	fsc_file_t *source_file = STACKPTR_SRC(source_file_ptr);
	fsc_stackptr_t export_file_ptr;
	fsc_file_t *export_file;
	int file_size;

	// Check if the file has already been loaded
	export_file_ptr = file_map_lookup(source_file_ptr, xw);
	if(export_file_ptr) return export_file_ptr;

	// Get file structure size for copy
	switch(source_file->sourcetype) {
		case FSC_SOURCETYPE_DIRECT: file_size = sizeof(fsc_file_direct_t); break;
		case FSC_SOURCETYPE_PK3: file_size = sizeof(fsc_file_frompk3_t); break;
		default: return 0; }	// Shouldn't happen

	// Generate copy of file in export_stack
	export_file_ptr = fsc_stack_allocate(&xw->export_stack, file_size);
	export_file = fsc_stack_retrieve(&xw->export_stack, export_file_ptr);
	fsc_memcpy(export_file, source_file, file_size);

	// Perform conversions
	export_file->qp_dir_ptr = convert_string(export_file->qp_dir_ptr, xw);
	export_file->qp_name_ptr = convert_string(export_file->qp_name_ptr, xw);
	export_file->qp_ext_ptr = convert_string(export_file->qp_ext_ptr, xw);
	if(source_file->sourcetype == FSC_SOURCETYPE_DIRECT) {
		fsc_file_direct_t *export_file_typed = (fsc_file_direct_t *)export_file;
		export_file_typed->qp_mod_ptr = convert_string(export_file_typed->qp_mod_ptr, xw);
		export_file_typed->refresh_count = 0;
		export_file_typed->source_dir_id = 0;
		// We can leave this null and let fsc_load_file patch it back in
		// It checks enough data already (qpath, size, timestamp, etc.) to reasonably assume
		// it is getting at least an identical file to the one cached
		export_file_typed->os_path_ptr = 0; }
	if(source_file->sourcetype == FSC_SOURCETYPE_PK3) {
		fsc_file_frompk3_t *export_file_typed = (fsc_file_frompk3_t *)export_file;
		export_file_typed->source_pk3 = convert_file(export_file_typed->source_pk3, xw); }

	// Insert file into filemap, hash table, and iteration system
	file_map_insert(source_file_ptr, export_file_ptr, xw);
	fsc_hashtable_insert(export_file_ptr, fsc_string_hash(STACKPTR_SRC(source_file->qp_name_ptr),
			STACKPTR_SRC(source_file->qp_dir_ptr)), &xw->export_files);
	fsc_iteration_register_file(export_file_ptr, &xw->export_directories, &xw->export_string_repository, &xw->export_stack);

	return export_file_ptr; }

void fscache_build_filesystem(export_work_t *xw) {
	int i;
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t source_file_ptr;

	// Estimate a reasonable hashtable size
	int hashtable_target_size = xw->source_fs->active_stats.cacheable_file_count;
	if(hashtable_target_size < 16384) hashtable_target_size = 16384;

	// Initialize temporary filemap
	fsc_stack_initialize(&xw->filemap_stack);
	fsc_hashtable_initialize(&xw->filemap, &xw->filemap_stack, hashtable_target_size);

	// Initialize export structures
	fsc_stack_initialize(&xw->export_stack);
	fsc_hashtable_initialize(&xw->export_string_repository, &xw->export_stack, hashtable_target_size);
	fsc_hashtable_initialize(&xw->export_files, &xw->export_stack, hashtable_target_size);
	fsc_hashtable_initialize(&xw->export_directories, &xw->export_stack, hashtable_target_size / 4);

	// Iterate and process all files in filesystem
	for(i=0; i<xw->source_fs->files.bucket_count; ++i) {
		fsc_hashtable_open(&xw->source_fs->files, i, &hti);
		while((source_file_ptr = fsc_hashtable_next(&hti))) {
			fsc_file_t *source_file = STACKPTR_SRC(source_file_ptr);
			if(!fsc_is_file_enabled(source_file, xw->source_fs)) continue;		// Process only active files
			if(source_file->sourcetype != FSC_SOURCETYPE_PK3) continue;		// Process only pk3 sourcetype files

			convert_file(source_file_ptr, xw); } } }

void fscache_build_shaders(export_work_t *xw) {
	int i;
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t source_shader_ptr;
	unsigned int hash;

	fsc_stackptr_t export_shader_ptr;
	fsc_shader_t *export_shader;

	// Estimate a reasonable hashtable size
	int hashtable_target_size = xw->source_fs->active_stats.shader_count;
	if(hashtable_target_size < 16384) hashtable_target_size = 16384;

	// Initialize export structure
	fsc_hashtable_initialize(&xw->export_shaders, &xw->export_stack, hashtable_target_size);

	// Iterate and process all shaders
	for(i=0; i<xw->source_fs->shaders.bucket_count; ++i) {
		fsc_hashtable_open(&xw->source_fs->shaders, i, &hti);
		while((source_shader_ptr = fsc_hashtable_next(&hti))) {
			fsc_shader_t *source_shader = STACKPTR_SRC(source_shader_ptr);
			if(!is_shader_enabled(xw->source_fs, source_shader)) continue;		// Process only active shaders

			// Allocate new shader
			export_shader_ptr = fsc_stack_allocate(&xw->export_stack, sizeof(fsc_shader_t));
			export_shader = fsc_stack_retrieve(&xw->export_stack, export_shader_ptr);
			fsc_memcpy(export_shader, source_shader, sizeof(fsc_shader_t));

			// Convert stackptrs within the shader
			export_shader->shader_name_ptr = convert_string(export_shader->shader_name_ptr, xw);
			export_shader->source_file_ptr = convert_file(export_shader->source_file_ptr, xw);

			// Add shader to export hashtable
			hash = fsc_string_hash(STACKPTR_SRC(source_shader->shader_name_ptr), 0);
			fsc_hashtable_insert(export_shader_ptr, hash, &xw->export_shaders); } } }

void fscache_build_crosshairs(export_work_t *xw) {
	int i;
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t source_crosshair_ptr;

	fsc_stackptr_t export_crosshair_ptr;
	fsc_crosshair_t *export_crosshair;

	// Initialize export structure
	fsc_hashtable_initialize(&xw->export_crosshairs, &xw->export_stack, 1);

	// Iterate and process all crosshairs
	for(i=0; i<xw->source_fs->crosshairs.bucket_count; ++i) {
		fsc_hashtable_open(&xw->source_fs->crosshairs, i, &hti);
		while((source_crosshair_ptr = fsc_hashtable_next(&hti))) {
			fsc_crosshair_t *source_crosshair = STACKPTR_SRC(source_crosshair_ptr);
			if(!is_crosshair_enabled(xw->source_fs, source_crosshair)) continue;		// Process only active crosshairs

			// Allocate new crosshair
			export_crosshair_ptr = fsc_stack_allocate(&xw->export_stack, sizeof(fsc_crosshair_t));
			export_crosshair = fsc_stack_retrieve(&xw->export_stack, export_crosshair_ptr);
			fsc_memcpy(export_crosshair, source_crosshair, sizeof(fsc_crosshair_t));

			// Convert stackptrs within the crosshair
			export_crosshair->source_file_ptr = convert_file(export_crosshair->source_file_ptr, xw);

			// Add crosshair to export hashtable
			fsc_hashtable_insert(export_crosshair_ptr, source_crosshair->hash, &xw->export_crosshairs); } } }

void fscache_build_pk3_hash_lookup(export_work_t *xw) {
	int i;
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t source_entry_ptr;

	// Estimate a reasonable hashtable size
	int hashtable_target_size = xw->source_fs->active_stats.valid_pk3_count;
	if(hashtable_target_size < 1024) hashtable_target_size = 1024;

	// Initialize export structure
	fsc_hashtable_initialize(&xw->export_pk3_hash_lookup, &xw->export_stack, hashtable_target_size);

	// Iterate and process all entries
	for(i=0; i<xw->source_fs->pk3_hash_lookup.bucket_count; ++i) {
		fsc_hashtable_open(&xw->source_fs->pk3_hash_lookup, i, &hti);
		while((source_entry_ptr = fsc_hashtable_next(&hti))) {
			fsc_stackptr_t output_pk3_file;
			fsc_pk3_hash_map_entry_t *source_entry = STACKPTR_SRC(source_entry_ptr);
			fsc_file_direct_t *source_pk3_file = STACKPTR_SRC(source_entry->pk3);
			if(!fsc_is_file_enabled((fsc_file_t *)source_pk3_file, xw->source_fs)) continue;

			output_pk3_file = convert_file(source_entry->pk3, xw);
			register_pk3_hash_lookup_entry(output_pk3_file, &xw->export_pk3_hash_lookup, &xw->export_stack); } } }

/* ******************************************************************************** */
// Main
/* ******************************************************************************** */

static int fsc_cache_export_data(fsc_filesystem_t *source_fs, fsc_stream_t *stream) {
	// Returns 1 on error, 0 on success. stream->data must be freed by caller on success.
	int error_state = 0;
	export_work_t xw;
	xw.source_fs = source_fs;

	// Build export data
	fscache_build_filesystem(&xw);
	fscache_build_shaders(&xw);
	fscache_build_crosshairs(&xw);
	fscache_build_pk3_hash_lookup(&xw);

	// Free filemap
	fsc_stack_free(&xw.filemap_stack);
	fsc_hashtable_free(&xw.filemap);

	// Set up export stream
	stream->size = fsc_stack_get_export_size(&xw.export_stack)
			+ fsc_hashtable_get_export_size(&xw.export_string_repository)
			+ fsc_hashtable_get_export_size(&xw.export_files)
			+ fsc_hashtable_get_export_size(&xw.export_directories)
			+ fsc_hashtable_get_export_size(&xw.export_shaders)
			+ fsc_hashtable_get_export_size(&xw.export_crosshairs)
			+ fsc_hashtable_get_export_size(&xw.export_pk3_hash_lookup);
	stream->data = fsc_malloc(stream->size);
	stream->position = 0;

	// Write export data to stream
	if(!error_state) if(fsc_stack_export(&xw.export_stack, stream)) error_state = 1;
	if(!error_state) if(fsc_hashtable_export(&xw.export_string_repository, stream)) error_state = 1;
	if(!error_state) if(fsc_hashtable_export(&xw.export_files, stream)) error_state = 1;
	if(!error_state) if(fsc_hashtable_export(&xw.export_directories, stream)) error_state = 1;
	if(!error_state) if(fsc_hashtable_export(&xw.export_shaders, stream)) error_state = 1;
	if(!error_state) if(fsc_hashtable_export(&xw.export_crosshairs, stream)) error_state = 1;
	if(!error_state) if(fsc_hashtable_export(&xw.export_pk3_hash_lookup, stream)) error_state = 1;

	// Free export data
	fsc_stack_free(&xw.export_stack);
	fsc_hashtable_free(&xw.export_string_repository);
	fsc_hashtable_free(&xw.export_files);
	fsc_hashtable_free(&xw.export_directories);
	fsc_hashtable_free(&xw.export_shaders);
	fsc_hashtable_free(&xw.export_crosshairs);
	fsc_hashtable_free(&xw.export_pk3_hash_lookup);

	if(error_state) fsc_free(stream->data);
	return error_state; }

static int fsc_cache_import_data(fsc_stream_t *stream, fsc_filesystem_t *target_fs) {
	// Returns 1 on error, 0 on success.
	fsc_memset(target_fs, 0, sizeof(*target_fs));

	if(fsc_stack_import(&target_fs->general_stack, stream)) goto error;
	if(fsc_hashtable_import(&target_fs->string_repository, &target_fs->general_stack, stream)) goto error;
	if(fsc_hashtable_import(&target_fs->files, &target_fs->general_stack, stream)) goto error;
	if(fsc_hashtable_import(&target_fs->directories, &target_fs->general_stack, stream)) goto error;
	if(fsc_hashtable_import(&target_fs->shaders, &target_fs->general_stack, stream)) goto error;
	if(fsc_hashtable_import(&target_fs->crosshairs, &target_fs->general_stack, stream)) goto error;
	if(fsc_hashtable_import(&target_fs->pk3_hash_lookup, &target_fs->general_stack, stream)) goto error;
	if(stream->size != stream->position) goto error;

	// Start refresh count at 2 instead of 1 so files will go into the "new"
	// stats category on the first refresh
	target_fs->refresh_count = 2;
	return 0;

	error:
	fsc_filesystem_free(target_fs);
	return 1; }

typedef struct {
	unsigned int version;
	unsigned int size;
} fscache_header_t;

int fsc_cache_export_file(fsc_filesystem_t *source_fs, void *os_path, fsc_errorhandler_t *eh) {
	// Returns 1 on error, 0 on success.
	fscache_header_t header;
	fsc_stream_t stream;
	void *fp;

	if(fsc_cache_export_data(source_fs, &stream)) {
		fsc_report_error(eh, FSC_ERROR_GENERAL, "error generating cache file data", 0);
		return 1; }

	// Open the output file and write header
	fp = fsc_open_file(os_path, "wb");
	if(!fp) {
		fsc_free(stream.data);
		fsc_report_error(eh, FSC_ERROR_GENERAL, "failed to open output file", 0);
		return 1; }
	header.version = FSC_CACHE_VERSION;
	header.size = stream.position;
	fsc_fwrite(&header, sizeof(header), fp);

	// Write the data
	fsc_fwrite(stream.data, header.size, fp);

	// Close file and free data
	fsc_fclose(fp);
	fsc_free(stream.data);
	return 0; }

int fsc_cache_import_file(void *os_path, fsc_filesystem_t *target_fs, fsc_errorhandler_t *eh) {
	// Returns 1 on error, 0 on success. On error filesystem will not be initialized.
	void *fp;
	fscache_header_t header;
	fsc_stream_t stream;

	// Open the input file and read header
	fp = fsc_open_file(os_path, "rb");
	if(!fp) {
		fsc_report_error(eh, FSC_ERROR_GENERAL, "failed to open input file", 0);
		return 1; }
	if(fsc_fread(&header, sizeof(header), fp) != sizeof(header)) {
		fsc_report_error(eh, FSC_ERROR_GENERAL, "failed to read cache file header", 0);
		fsc_fclose(fp);
		return 1; }
	if(header.version != FSC_CACHE_VERSION) {
		fsc_report_error(eh, FSC_ERROR_GENERAL, "cache file has wrong version", 0);
		fsc_fclose(fp);
		return 1; }

	// Read compressed data and close file
	stream.data = fsc_malloc(header.size);
	if(fsc_fread(stream.data, header.size, fp) != header.size) {
		fsc_report_error(eh, FSC_ERROR_GENERAL, "error reading cache file data", 0);
		return 1; }
	fsc_fclose(fp);

	// Load data into filesystem
	stream.position = 0;
	stream.size = header.size;
	if(fsc_cache_import_data(&stream, target_fs)) {
		fsc_report_error(eh, FSC_ERROR_GENERAL, "error loading cache data", 0);
		return 1; }

	// Free the data
	fsc_free(stream.data);
	return 0; }

#endif	// NEW_FILESYSTEM
