/*
===========================================================================
Copyright (C) 2017 Noah Metzger (chomenor@gmail.com)

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Quake III Arena source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/

#ifdef NEW_FILESYSTEM
#include "fscore.h"

#define STACKPTR_SRC( pointer ) ( FSC_STACK_RETRIEVE( &xw->source_fs->general_stack, pointer, fsc_false ) ) // non-null

typedef struct {
	unsigned int version;
	unsigned int size;
} fscache_header_t;

typedef struct {
	fsc_filesystem_t *source_fs;

	// Temporary - not written to file
	fsc_stack_t filemap_stack;
	fsc_hashtable_t filemap;

	// Generated by various export functions
	fsc_stack_t export_stack;
	fsc_hashtable_t export_string_repository;

	// Generated by fscache_export_filesystem
	fsc_hashtable_t export_files;
	fsc_hashtable_t export_directories;

	// Generated by fscache_export_shaders
	fsc_hashtable_t export_shaders;

	// Generated by fscache_export_crosshairs
	fsc_hashtable_t export_crosshairs;

	// Generated by FSC_CacheExportPk3HashLookup
	fsc_hashtable_t export_pk3_hash_lookup;
} export_work_t;

typedef struct {
	// Hash table compliance
	fsc_hashtable_entry_t hte;

	fsc_stackptr_t source_file_ptr;
	fsc_stackptr_t export_file_ptr;
} filemap_entry_t;

/*
=================
FSC_CacheIntegerHash
=================
*/
static unsigned int FSC_CacheIntegerHash( unsigned int value ) {
	return ( value >> 2 ) | ( value >> 5 );
}

/*
=================
FSC_CacheConvertString

Provides a string pointer in the source filesystem, returns equivalent string in export filesystem.
=================
*/
static fsc_stackptr_t FSC_CacheConvertString( fsc_stackptr_t source_string, export_work_t *xw ) {
	if ( !source_string ) {
		return FSC_SPNULL;
	}
	return FSC_StringRepositoryGetString( (const char *)STACKPTR_SRC( source_string ), &xw->export_string_repository );
}

/*
=================
FSC_CacheFileMapLookup

Provided a pointer to a file in the source filesystem, returns equivalent file in the export filesystem,
or null if it doesn't yet exist.
=================
*/
static fsc_stackptr_t FSC_CacheFileMapLookup( fsc_stackptr_t source_file_ptr, export_work_t *xw ) {
	unsigned int hash = FSC_CacheIntegerHash( source_file_ptr );
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t filemap_entry_ptr;
	filemap_entry_t *filemap_entry;

	FSC_HashtableIterateBegin( &xw->filemap, hash, &hti );
	while ( ( filemap_entry_ptr = FSC_HashtableIterateNext( &hti ) ) ) {
		filemap_entry = (filemap_entry_t *)FSC_STACK_RETRIEVE( &xw->filemap_stack, filemap_entry_ptr, fsc_false );
		if ( filemap_entry->source_file_ptr == source_file_ptr ) {
			return filemap_entry->export_file_ptr;
		}
	}

	return FSC_SPNULL;
}

/*
=================
FSC_CacheFileMapInsert

Adds new file in the export filesystem to temporary file map structure so FSC_CacheFileMapLookup can find it.
=================
*/
static void FSC_CacheFileMapInsert( fsc_stackptr_t source_file_ptr, fsc_stackptr_t export_file_ptr, export_work_t *xw ) {
	unsigned int hash = FSC_CacheIntegerHash( source_file_ptr );
	fsc_stackptr_t filemap_entry_ptr;
	filemap_entry_t *filemap_entry;

	filemap_entry_ptr = FSC_StackAllocate( &xw->filemap_stack, sizeof( filemap_entry_t ) );
	filemap_entry = (filemap_entry_t *)FSC_STACK_RETRIEVE( &xw->filemap_stack, filemap_entry_ptr, fsc_false );

	filemap_entry->source_file_ptr = source_file_ptr;
	filemap_entry->export_file_ptr = export_file_ptr;
	FSC_HashtableInsert( filemap_entry_ptr, hash, &xw->filemap );
}

/*
=================
FSC_CacheConvertFile

Converts file from source filesystem to export filesystem if not already converted.
If file is already converted, just returns the existing converted file.
Should only be called for direct or pk3 sourcetype files (not custom sourcetypes).
=================
*/
static fsc_stackptr_t FSC_CacheConvertFile( fsc_stackptr_t source_file_ptr, export_work_t *xw ) {
	fsc_file_t *source_file = (fsc_file_t *)STACKPTR_SRC( source_file_ptr );
	fsc_stackptr_t export_file_ptr;
	fsc_file_t *export_file;
	int file_size = 0;

	// Check if the file has already been converted
	export_file_ptr = FSC_CacheFileMapLookup( source_file_ptr, xw );
	if ( export_file_ptr ) {
		return export_file_ptr;
	}

	// Get file structure size for copy
	if ( source_file->sourcetype == FSC_SOURCETYPE_DIRECT ) {
		file_size = sizeof( fsc_file_direct_t );
	} else if ( source_file->sourcetype == FSC_SOURCETYPE_PK3 ) {
		file_size = sizeof( fsc_file_frompk3_t );
	} else {
		FSC_ReportError( FSC_ERRORLEVEL_FATAL, FSC_ERROR_GENERAL, "FSC_CacheConvertFile called on unsupported sourcetype", source_file );
	}

	// Generate copy of file in export_stack
	export_file_ptr = FSC_StackAllocate( &xw->export_stack, file_size );
	export_file = (fsc_file_t *)FSC_STACK_RETRIEVE( &xw->export_stack, export_file_ptr, fsc_false );
	FSC_Memcpy( export_file, source_file, file_size );

	// Reallocate stackptrs from original stack to export stack and other adjustments
	export_file->qp_dir_ptr = FSC_CacheConvertString( export_file->qp_dir_ptr, xw );
	export_file->qp_name_ptr = FSC_CacheConvertString( export_file->qp_name_ptr, xw );
	export_file->qp_ext_ptr = FSC_CacheConvertString( export_file->qp_ext_ptr, xw );
	if ( export_file->contents_cache ) {
		export_file->contents_cache = FSC_StackAllocate( &xw->export_stack, source_file->filesize );
		FSC_Memcpy( FSC_STACK_RETRIEVE( &xw->export_stack, export_file->contents_cache, fsc_false ),
				STACKPTR_SRC( source_file->contents_cache ), source_file->filesize );
	}
	if ( source_file->sourcetype == FSC_SOURCETYPE_DIRECT ) {
		fsc_file_direct_t *export_file_typed = (fsc_file_direct_t *)export_file;
		export_file_typed->qp_mod_ptr = FSC_CacheConvertString( export_file_typed->qp_mod_ptr, xw );
		export_file_typed->pk3dir_ptr = FSC_CacheConvertString( export_file_typed->pk3dir_ptr, xw );
		export_file_typed->refresh_count = 0;
		export_file_typed->source_dir_id = 0;
		// We can leave this null and let FSC_LoadFile patch it back in
		// It checks enough data already (qpath, size, timestamp, etc.) to reasonably assume
		// it is getting at least an identical file to the one cached
		export_file_typed->os_path_ptr = FSC_SPNULL;
	}
	if ( source_file->sourcetype == FSC_SOURCETYPE_PK3 ) {
		fsc_file_frompk3_t *export_file_typed = (fsc_file_frompk3_t *)export_file;
		export_file_typed->source_pk3 = FSC_CacheConvertFile( export_file_typed->source_pk3, xw );
	}

	// Insert file into filemap, hash table, and iteration system
	FSC_CacheFileMapInsert( source_file_ptr, export_file_ptr, xw );
	FSC_HashtableInsert( export_file_ptr, FSC_StringHash( (const char *)STACKPTR_SRC( source_file->qp_name_ptr ),
			(const char *)STACKPTR_SRC( source_file->qp_dir_ptr ) ), &xw->export_files );
	FSC_IterationRegisterFile( export_file_ptr, &xw->export_directories, &xw->export_string_repository, &xw->export_stack );

	return export_file_ptr;
}

/*
=================
FSC_CacheExportFiles
=================
*/
static void FSC_CacheExportFiles( export_work_t *xw ) {
	int i;
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t source_file_ptr;

	// Estimate a reasonable hashtable size
	int hashtable_target_size = xw->source_fs->active_stats.cacheable_file_count;
	if ( hashtable_target_size < 16384 ) {
		hashtable_target_size = 16384;
	}

	// Initialize temporary filemap
	FSC_StackInitialize( &xw->filemap_stack );
	FSC_HashtableInitialize( &xw->filemap, &xw->filemap_stack, hashtable_target_size );

	// Initialize export structures
	FSC_StackInitialize( &xw->export_stack );
	FSC_HashtableInitialize( &xw->export_string_repository, &xw->export_stack, hashtable_target_size );
	FSC_HashtableInitialize( &xw->export_files, &xw->export_stack, hashtable_target_size );
	FSC_HashtableInitialize( &xw->export_directories, &xw->export_stack, hashtable_target_size / 4 );

	// Iterate and process all files in filesystem
	for ( i = 0; i < xw->source_fs->files.bucket_count; ++i ) {
		FSC_HashtableIterateBegin( &xw->source_fs->files, i, &hti );
		while ( ( source_file_ptr = FSC_HashtableIterateNext( &hti ) ) ) {
			fsc_file_t *source_file = (fsc_file_t *)STACKPTR_SRC( source_file_ptr );

			// Process active files from pk3 sources, or from direct sources if contents_cache is set.
			// Files referenced by shaders or crosshairs will be cached in their own cycle below,
			// if not already cached here.
			if ( !FSC_IsFileActive( source_file, xw->source_fs ) ) {
				continue;
			}
			if ( source_file->sourcetype == FSC_SOURCETYPE_PK3 ||
					( source_file->sourcetype == FSC_SOURCETYPE_DIRECT && source_file->contents_cache ) ) {
				FSC_CacheConvertFile( source_file_ptr, xw );
			}
		}
	}
}

/*
=================
FSC_CacheExportShaders
=================
*/
static void FSC_CacheExportShaders( export_work_t *xw ) {
	int i;
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t source_shader_ptr;
	unsigned int hash;

	fsc_stackptr_t export_shader_ptr;
	fsc_shader_t *export_shader;

	// Estimate a reasonable hashtable size
	int hashtable_target_size = xw->source_fs->active_stats.shader_count;
	if ( hashtable_target_size < 16384 ) {
		hashtable_target_size = 16384;
	}

	// Initialize export structure
	FSC_HashtableInitialize( &xw->export_shaders, &xw->export_stack, hashtable_target_size );

	// Iterate and process all shaders
	for ( i = 0; i < xw->source_fs->shaders.bucket_count; ++i ) {
		FSC_HashtableIterateBegin( &xw->source_fs->shaders, i, &hti );
		while ( ( source_shader_ptr = FSC_HashtableIterateNext( &hti ) ) ) {
			const fsc_shader_t *source_shader = (fsc_shader_t *)STACKPTR_SRC( source_shader_ptr );
			const fsc_file_t *source_file = (const fsc_file_t *)STACKPTR_SRC( source_shader->source_file_ptr );

			// Process only active shaders from direct/pk3 sources
			if ( source_file->sourcetype != FSC_SOURCETYPE_DIRECT && source_file->sourcetype != FSC_SOURCETYPE_PK3 ) {
				continue;
			}
			if ( !FSC_IsShaderActive( xw->source_fs, source_shader ) ) {
				continue;
			}

			// Allocate new shader
			export_shader_ptr = FSC_StackAllocate( &xw->export_stack, sizeof( fsc_shader_t ) );
			export_shader = (fsc_shader_t *)FSC_STACK_RETRIEVE( &xw->export_stack, export_shader_ptr, fsc_false );
			FSC_Memcpy( export_shader, source_shader, sizeof( fsc_shader_t ) );

			// Convert stackptrs within the shader
			export_shader->shader_name_ptr = FSC_CacheConvertString( export_shader->shader_name_ptr, xw );
			export_shader->source_file_ptr = FSC_CacheConvertFile( export_shader->source_file_ptr, xw );

			// Add shader to export hashtable
			hash = FSC_StringHash( (const char *)STACKPTR_SRC( source_shader->shader_name_ptr ), FSC_NULL );
			FSC_HashtableInsert( export_shader_ptr, hash, &xw->export_shaders );
		}
	}
}

/*
=================
FSC_CacheExportCrosshairs
=================
*/
static void FSC_CacheExportCrosshairs( export_work_t *xw ) {
	int i;
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t source_crosshair_ptr;

	fsc_stackptr_t export_crosshair_ptr;
	fsc_crosshair_t *export_crosshair;

	// Initialize export structure
	FSC_HashtableInitialize( &xw->export_crosshairs, &xw->export_stack, 1 );

	// Iterate and process all crosshairs
	for ( i = 0; i < xw->source_fs->crosshairs.bucket_count; ++i ) {
		FSC_HashtableIterateBegin( &xw->source_fs->crosshairs, i, &hti );
		while ( ( source_crosshair_ptr = FSC_HashtableIterateNext( &hti ) ) ) {
			const fsc_crosshair_t *source_crosshair = (fsc_crosshair_t *)STACKPTR_SRC( source_crosshair_ptr );
			const fsc_file_t *source_file = (const fsc_file_t *)STACKPTR_SRC( source_crosshair->source_file_ptr );

			// Process only active crosshairs from direct/pk3 sources
			if ( source_file->sourcetype != FSC_SOURCETYPE_DIRECT && source_file->sourcetype != FSC_SOURCETYPE_PK3 ) {
				continue;
			}
			if ( !FSC_IsCrosshairActive( xw->source_fs, source_crosshair ) ) {
				continue;
			}

			// Allocate new crosshair
			export_crosshair_ptr = FSC_StackAllocate( &xw->export_stack, sizeof( fsc_crosshair_t ) );
			export_crosshair = (fsc_crosshair_t *)FSC_STACK_RETRIEVE( &xw->export_stack, export_crosshair_ptr, fsc_false );
			FSC_Memcpy( export_crosshair, source_crosshair, sizeof( fsc_crosshair_t ) );

			// Convert stackptrs within the crosshair
			export_crosshair->source_file_ptr = FSC_CacheConvertFile( export_crosshair->source_file_ptr, xw );

			// Add crosshair to export hashtable
			FSC_HashtableInsert( export_crosshair_ptr, source_crosshair->hash, &xw->export_crosshairs );
		}
	}
}

/*
=================
FSC_CacheExportPk3HashLookup
=================
*/
static void FSC_CacheExportPk3HashLookup( export_work_t *xw ) {
	int i;
	fsc_hashtable_iterator_t hti;
	fsc_stackptr_t source_entry_ptr;

	// Estimate a reasonable hashtable size
	int hashtable_target_size = xw->source_fs->active_stats.valid_pk3_count;
	if ( hashtable_target_size < 1024 ) {
		hashtable_target_size = 1024;
	}

	// Initialize export structure
	FSC_HashtableInitialize( &xw->export_pk3_hash_lookup, &xw->export_stack, hashtable_target_size );

	// Iterate and process all entries
	for ( i = 0; i < xw->source_fs->pk3_hash_lookup.bucket_count; ++i ) {
		FSC_HashtableIterateBegin( &xw->source_fs->pk3_hash_lookup, i, &hti );
		while ( ( source_entry_ptr = FSC_HashtableIterateNext( &hti ) ) ) {
			fsc_stackptr_t output_pk3_file;
			fsc_pk3_hash_map_entry_t *source_entry = (fsc_pk3_hash_map_entry_t *)STACKPTR_SRC( source_entry_ptr );
			fsc_file_direct_t *source_pk3_file = (fsc_file_direct_t *)STACKPTR_SRC( source_entry->pk3 );
			if ( !FSC_IsFileActive( (fsc_file_t *)source_pk3_file, xw->source_fs ) ) {
				continue;
			}

			output_pk3_file = FSC_CacheConvertFile( source_entry->pk3, xw );
			FSC_RegisterPk3HashLookup( output_pk3_file, &xw->export_pk3_hash_lookup, &xw->export_stack );
		}
	}
}

/*
=================
FSC_CacheExportStream

Generates cache-ready copy of filesystem and writes it to stream.
Returns true on error, false on success. On success, stream->data must be freed by caller using FSC_Free.
=================
*/
static fsc_boolean FSC_CacheExportStream( fsc_filesystem_t *source_fs, fsc_stream_t *stream ) {
	fsc_boolean error_state = fsc_false;
	export_work_t xw;
	xw.source_fs = source_fs;

	// Build export data
	FSC_CacheExportFiles( &xw );
	FSC_CacheExportShaders( &xw );
	FSC_CacheExportCrosshairs( &xw );
	FSC_CacheExportPk3HashLookup( &xw );

	// Free filemap
	FSC_StackFree( &xw.filemap_stack );
	FSC_HashtableFree( &xw.filemap );

	// Set up export stream
	stream->size = FSC_StackExportSize( &xw.export_stack )
			+ FSC_HashtableExportSize( &xw.export_string_repository )
			+ FSC_HashtableExportSize( &xw.export_files )
			+ FSC_HashtableExportSize( &xw.export_directories )
			+ FSC_HashtableExportSize( &xw.export_shaders )
			+ FSC_HashtableExportSize( &xw.export_crosshairs )
			+ FSC_HashtableExportSize( &xw.export_pk3_hash_lookup );
	stream->data = (char *)FSC_Malloc( stream->size );
	stream->position = 0;

	// Write export data to stream
	if ( FSC_StackExport( &xw.export_stack, stream )
			|| FSC_HashtableExport( &xw.export_string_repository, stream )
			|| FSC_HashtableExport( &xw.export_files, stream )
			|| FSC_HashtableExport( &xw.export_directories, stream )
			|| FSC_HashtableExport( &xw.export_shaders, stream )
			|| FSC_HashtableExport( &xw.export_crosshairs, stream )
			|| FSC_HashtableExport( &xw.export_pk3_hash_lookup, stream ) ) {
		error_state = fsc_true;
	}

	// Free export data
	FSC_StackFree( &xw.export_stack );
	FSC_HashtableFree( &xw.export_string_repository );
	FSC_HashtableFree( &xw.export_files );
	FSC_HashtableFree( &xw.export_directories );
	FSC_HashtableFree( &xw.export_shaders );
	FSC_HashtableFree( &xw.export_crosshairs );
	FSC_HashtableFree( &xw.export_pk3_hash_lookup );

	if ( error_state ) {
		FSC_Free( stream->data );
		stream->data = FSC_NULL;
	}
	return error_state;
}

/*
=================
FSC_CacheImportStream

Imports filesystem from stream. Returns true on error, false on success.
=================
*/
static fsc_boolean FSC_CacheImportStream( fsc_stream_t *stream, fsc_filesystem_t *target_fs ) {
	FSC_Memset( target_fs, 0, sizeof( *target_fs ) );

	if( FSC_StackImport( &target_fs->general_stack, stream ) ||
			FSC_HashtableImport( &target_fs->string_repository, &target_fs->general_stack, stream ) ||
			FSC_HashtableImport( &target_fs->files, &target_fs->general_stack, stream ) ||
			FSC_HashtableImport( &target_fs->directories, &target_fs->general_stack, stream ) ||
			FSC_HashtableImport( &target_fs->shaders, &target_fs->general_stack, stream ) ||
			FSC_HashtableImport( &target_fs->crosshairs, &target_fs->general_stack, stream ) ||
			FSC_HashtableImport( &target_fs->pk3_hash_lookup, &target_fs->general_stack, stream ) ||
			stream->size != stream->position ) {
		FSC_FilesystemFree( target_fs );
		return fsc_true;
	}

	// Start refresh count at 2 instead of 1 so files will go into the "new"
	// stats category on the first refresh.
	target_fs->refresh_count = 2;
	return fsc_false;
}

/*
=================
FSC_CacheExportFileRawPath

Generates cache-ready copy of filesystem and writes it to file.
Returns true on error, false on success.
=================
*/
fsc_boolean FSC_CacheExportFileRawPath( fsc_filesystem_t *source_fs, fsc_ospath_t *os_path ) {
	fscache_header_t header;
	fsc_stream_t stream;
	fsc_filehandle_t *fp;

	if ( FSC_CacheExportStream( source_fs, &stream ) ) {
		FSC_ReportError( FSC_ERRORLEVEL_WARNING, FSC_ERROR_GENERAL, "error generating cache file data", FSC_NULL );
		return fsc_true;
	}

	// Open the output file and write header
	fp = FSC_FOpenRaw( os_path, "wb" );
	if ( !fp ) {
		FSC_Free( stream.data );
		FSC_ReportError( FSC_ERRORLEVEL_WARNING, FSC_ERROR_GENERAL, "failed to open output file", FSC_NULL );
		return fsc_true;
	}
	header.version = FSC_CACHE_VERSION;
	header.size = stream.position;
	FSC_FWrite( &header, sizeof( header ), fp );

	// Write the data
	FSC_FWrite( stream.data, header.size, fp );

	// Close file and free data
	FSC_FClose( fp );
	FSC_Free( stream.data );
	return fsc_false;
}

/*
=================
FSC_CacheExportFile

Standard string path wrapper for FSC_CacheExportFileRawPath.
=================
*/
fsc_boolean FSC_CacheExportFile( fsc_filesystem_t *source_fs, const char *path ) {
	fsc_ospath_t *os_path = FSC_StringToOSPath( path );
	fsc_boolean result = FSC_CacheExportFileRawPath( source_fs, os_path );
	FSC_Free( os_path );
	return result;
}

/*
=================
FSC_CacheImportFileRawPath

Imports filesystem from file. Returns true on error, false on success.
=================
*/
fsc_boolean FSC_CacheImportFileRawPath( fsc_ospath_t *os_path, fsc_filesystem_t *target_fs ) {
	fsc_filehandle_t *fp;
	fscache_header_t header;
	fsc_stream_t stream;

	// Open the input file and read header
	fp = FSC_FOpenRaw( os_path, "rb" );
	if ( !fp ) {
		FSC_ReportError( FSC_ERRORLEVEL_WARNING, FSC_ERROR_GENERAL, "failed to open input file", FSC_NULL );
		return fsc_true;
	}
	if ( FSC_FRead( &header, sizeof( header ), fp ) != sizeof( header ) ) {
		FSC_ReportError( FSC_ERRORLEVEL_WARNING, FSC_ERROR_GENERAL, "failed to read cache file header", FSC_NULL );
		FSC_FClose( fp );
		return fsc_true;
	}
	if ( header.version != FSC_CACHE_VERSION ) {
		FSC_ReportError( FSC_ERRORLEVEL_WARNING, FSC_ERROR_GENERAL, "cache file has wrong version", FSC_NULL );
		FSC_FClose( fp );
		return fsc_true;
	}

	// Read data and close file
	stream.data = (char *)FSC_Malloc( header.size );
	if ( FSC_FRead( stream.data, header.size, fp ) != header.size ) {
		FSC_ReportError( FSC_ERRORLEVEL_WARNING, FSC_ERROR_GENERAL, "error reading cache file data", FSC_NULL );
		return fsc_true;
	}
	FSC_FClose( fp );

	// Load data into filesystem
	stream.position = 0;
	stream.size = header.size;
	if ( FSC_CacheImportStream( &stream, target_fs ) ) {
		FSC_ReportError( FSC_ERRORLEVEL_WARNING, FSC_ERROR_GENERAL, "error loading cache data", FSC_NULL );
		return fsc_true;
	}

	// Free the data
	FSC_Free( stream.data );
	return fsc_false;
}

/*
=================
FSC_CacheImportFile

Standard string path wrapper for FSC_CacheImportFileRawPath.
=================
*/
fsc_boolean FSC_CacheImportFile( const char *path, fsc_filesystem_t *target_fs ) {
	fsc_ospath_t *os_path = FSC_StringToOSPath( path );
	fsc_boolean result = FSC_CacheImportFileRawPath( os_path, target_fs );
	FSC_Free( os_path );
	return result;
}

#endif	// NEW_FILESYSTEM
