/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.
Copyright (C) 2017 Noah Metzger (chomenor@gmail.com)

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Quake III Arena source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/

#ifdef CMOD_CVAR_HANDLING
#include "../qcommon/q_shared.h"
#include "../qcommon/qcommon.h"

int cvar_modifiedFlags;		// Publicly shared

static cvar_t *sv_cheats;
static cvar_t *cvar_debug;

#define CVAR_DEBUG ( cvar_debug ? cvar_debug->integer : 0 )

/*
###############################################################################################

Definitions

###############################################################################################
*/

// Value objects consist of a value string and certain flags (typically "created" flags)
// that are paired with the value.
typedef struct {
	char *string;	// NULL if not set
	int flags;
} cvarValue_t;

// Flags in engine_flags, main_flags, and temporary_flags are always transferred to the output
// cvar->s.flags, but flags from value objects are only transferred from the particular value
// that is used.

typedef struct localCvar_s {
	// Components shared with the rest of the game, and defined in q_shared.h
	cvar_t s;

	// System values - set by system code (e.g. Cvar_Get), represents engine defaults
	cvarValue_t engine_default;
	int engine_flags;

	// Main values - Persistent values set by user, engine, or trusted VMs
	// May be written to config file if archive flag is present
	cvarValue_t main_value;
	int main_flags;

	// Temporary values - cleared when session ends & never written to any config file
	cvarValue_t game_default;
	cvarValue_t temporary_value;
	int temporary_flags;

	// Generated by Cvar_Finalize
	cvarValue_t current_value;

	// Validations
	qboolean validate;
	qboolean integral;
	float min;
	float max;

	// Misc
	int vm_handle;	// For sharing with VMs
	int category;	// To make settings file more readable
	char *description;

	// Iteration
	struct localCvar_s *next;
	struct localCvar_s *prev;

	// Hashtable
	struct localCvar_s *hash_next;
	struct localCvar_s *hash_prev;
	int hash;
} localCvar_t;

typedef struct {
	char *data;
	unsigned int position;
	unsigned int size;
	qboolean overflowed;
} cvar_stream_t;

// These should only be set in the value-specific (cvarValue_t) flags field
#ifdef CMOD_SAFE_AUTOEXEC
#define CVAR_CREATED_FLAGS ( CVAR_USER_CREATED | CVAR_VM_CREATED | CVAR_SERVER_CREATED | \
	CVAR_TRUSTED_CREATED | CVAR_RESTRICTED_AUTOEXEC_CREATED )
#else
#define CVAR_CREATED_FLAGS ( CVAR_USER_CREATED | CVAR_VM_CREATED | CVAR_SERVER_CREATED | CVAR_TRUSTED_CREATED )
#endif

/*
###############################################################################################

Misc support functions

###############################################################################################
*/

/*
=================
Cvar_HashValue
=================
*/
static int Cvar_HashValue( const char *name ) {
	int i;
	int hash;
	char letter;

	hash = 0;
	i = 0;
	while ( name[i] != '\0' ) {
		letter = tolower( name[i] );
		hash += (long)( letter ) * ( i + 119 );
		i++;
	}

	return hash;
}

/*
=================
Cvar_StreamAppendString

If stream runs out of space, output is truncated.
Stream data will always be null terminated.
=================
*/
static void Cvar_StreamAppendString( cvar_stream_t *stream, const char *string ) {
	while ( *string ) {
		if ( stream->position >= stream->size - 1 ) {
			stream->overflowed = qtrue;
			break;
		}
		stream->data[stream->position++] = *( string++ );
	}
	if ( stream->position >= stream->size ) {
		// shouldn't happen
		Com_Error( ERR_FATAL, "Cvar_StreamAppendString overflow" );
	}
	stream->data[stream->position] = '\0';
}

// Some stream macros
#define ADD_TEXT( string ) Cvar_StreamAppendString( &stream, string )
#define ADD_TEXT2( string ) Cvar_StreamAppendString( stream, string )

/*
###############################################################################################

Memory management

###############################################################################################
*/

static const char cvar_mstatic[][2] = { {0,0}, {'0',0}, {'1',0} };

#define IS_STATIC_STRING( str ) ( !str || ( (char *)( str ) >= *cvar_mstatic && (char *)( str ) < *cvar_mstatic + sizeof( cvar_mstatic ) ) )

/*
=================
Cvar_Malloc
=================
*/
static void *Cvar_Malloc( int size ) {
	int *countptr = S_Malloc( size + sizeof( int ) );
	*countptr = 1;
	return countptr + 1;
}

/*
=================
Cvar_MFree
=================
*/
static void Cvar_MFree( void *data ) {
	int *countptr;
	if ( IS_STATIC_STRING( data ) ) {
		return;
	}
	countptr = (int *)data - 1;
	if ( --*countptr <= 0 ) {
		Z_Free( countptr );
	}
}

/*
=================
Cvar_Copystring

Makes a copy of string from source into target. Existing contents of target will be freed.

Source string can be any string or NULL.
Target string must be either NULL or a string allocated by Cvar_Copystring or Cvar_Linkstring.
=================
*/
static void Cvar_Copystring( const char *source, char **target ) {
	Cvar_MFree( *target );
	*target = NULL;
	if ( source )	{
		int len = strlen( source );
		if ( len == 0 ) {
			*target = (char *)cvar_mstatic[0];
		} else if ( len == 1 && source[0] == '0' ) {
			*target = (char *)cvar_mstatic[1];
		} else if ( len == 1 && source[0] == '1' ) {
			*target = (char *)cvar_mstatic[2];
		} else {
			*target = Cvar_Malloc( len + 1 );
			memcpy( *target, source, len );
			( *target )[len] = '\0';
		}
	}
}

/*
=================
Cvar_Linkstring

Functionally the same as Cvar_Copystring, but uses reference counting instead of a string
copy for better performance.

Both source string and target string must be either NULL or a string allocated with Cvar_Copystring or Cvar_Linkstring.
=================
*/
static void Cvar_Linkstring( char *source, char **target ) {
	Cvar_MFree( *target );
	*target = source;
	if ( !IS_STATIC_STRING( source ) ) {
		int *countptr = (int *)source - 1;
		++*countptr;
	}
}

/*
=================
Cvar_Clearstring

Frees existing contents of target and resets to NULL.
Target string must be either NULL or a string allocated with Cvar_Copystring or Cvar_Linkstring.
=================
*/
static void Cvar_Clearstring( char **target ) {
	Cvar_MFree( *target );
	*target = NULL;
}

/*
###############################################################################################

Validation functions

###############################################################################################
*/

/*
=================
Cvar_ValidName
=================
*/
static qboolean Cvar_ValidName( const char *s ) {
	if ( !s || !*s )
		return qfalse;
	if ( strlen( s ) > 1000 )
		return qfalse;
	if ( strchr( s, '\"' ) )
		return qfalse;
	if ( strchr( s, '\\' ) )
		return qfalse;
	if ( strchr( s, ';' ) )
		return qfalse;
	if ( strchr( s, '\n' ) )
		return qfalse;
	if ( strchr( s, '\r' ) )
		return qfalse;
	return qtrue;
}

/*
=================
Cvar_CheckRange2
=================
*/
static void Cvar_CheckRange2( localCvar_t *cvar, char **string, qboolean warn ) {
	qboolean changed = qfalse;
	float valuef;

	if ( !cvar->validate ) {
		return;
	}
	valuef = atof( *string );

	if ( !Q_isanumber( *string ) ) {
		if ( warn ) {
			Com_Printf( "WARNING: cvar '%s' must be numeric\n", cvar->s.name );
		}
		if ( cvar->s.resetString ) {
			valuef = atof( cvar->s.resetString );
		} else {
			valuef = 0.0f;
		}
		changed = qtrue;
	}

	if ( valuef < cvar->min ) {
		if ( warn ) {
			Com_Printf( "WARNING: cvar '%s' out of range (min %f)\n", cvar->s.name, cvar->min );
		}
		valuef = cvar->min;
		changed = qtrue;
	}

	if ( valuef > cvar->max ) {
		if ( warn ) {
			Com_Printf( "WARNING: cvar '%s' out of range (max %f)\n", cvar->s.name, cvar->max );
		}
		valuef = cvar->max;
		changed = qtrue;
	}

	if ( cvar->integral && !Q_isintegral( valuef ) ) {
		if ( warn ) {
			Com_Printf( "WARNING: cvar '%s' must be integral\n", cvar->s.name );
		}
		valuef = (int)valuef;
		changed = qtrue;
	}

	if ( changed ) {
		char temp[20];
		if ( Q_isintegral( valuef ) ) {
			Com_sprintf( temp, sizeof( temp ), "%i", (int)valuef );
		} else {
			Com_sprintf( temp, sizeof( temp ), "%f", valuef );
		}
		Cvar_Copystring( temp, string );
	}
}

/* ******************************************************************************** */
// Cvar Storage
/* ******************************************************************************** */

#define CVAR_TABLE_SIZE 1024
static localCvar_t *cvar_table[CVAR_TABLE_SIZE];

static localCvar_t *cvar_first;
static localCvar_t *cvar_last;

/*
=================
Cvar_FindOrCreate

Returns cvar on success, NULL on false.
May return NULL even if create is specified, if name fails to validate.
=================
*/
static localCvar_t *Cvar_FindOrCreate( const char *name, qboolean create ) {
	int hash = Cvar_HashValue( name );
	int hash_index = hash % CVAR_TABLE_SIZE;
	localCvar_t *current = cvar_table[hash_index];
	while ( current ) {
		if ( current->hash == hash && !Q_stricmp( name, current->s.name ) ) {
			return current;
		}
		current = current->hash_next;
	}

	if ( !create ) {
		return NULL;
	}
	if ( !Cvar_ValidName( name ) ) {
		Com_Printf( "invalid cvar name string: %s\n", name );
		return NULL;
	}

	current = S_Malloc( sizeof( *current ) );
	Com_Memset( current, 0, sizeof( *current ) );
	Cvar_Copystring( name, &current->s.name );
	Cvar_Copystring( "", &current->s.string );
	Cvar_Copystring( "", &current->s.resetString );
	current->s.modified = qtrue;
	current->s.modificationCount = 1;

	current->hash = hash;
	current->hash_next = cvar_table[hash_index];
	if ( cvar_table[hash_index] ) {
		cvar_table[hash_index]->hash_prev = current;
	}
	cvar_table[hash_index] = current;

	current->prev = cvar_last;
	if ( cvar_last ) {
		cvar_last->next = current;
	}
	cvar_last = current;
	if ( !cvar_first ) {
		cvar_first = current;
	}

	return current;
}

/*
###############################################################################################

Primary Cvar Modifiers

###############################################################################################
*/

/*
=================
Cvar_SetValueObject
=================
*/
static void Cvar_SetValueObject( cvarValue_t *out, const char *string, int flags ) {
	Cvar_Copystring( string, &out->string );
	out->flags = flags;
}

/*
=================
Cvar_CopyValueObject
=================
*/
static void Cvar_CopyValueObject( cvarValue_t *source, cvarValue_t *out ) {
	Cvar_Linkstring( source->string, &out->string );
	out->flags = source->flags;
}

/*
=================
Cvar_ClearValueObject
=================
*/
static void Cvar_ClearValueObject( cvarValue_t *object ) {
	Cvar_Clearstring( &object->string );
	object->flags = 0;
}

/*
=================
Cvar_CopyDefaultToValueObject

Copy a cvar's default/reset value to a value object.
=================
*/
static void Cvar_CopyDefaultToValueObject( localCvar_t *cvar, cvarValue_t *out ) {
	if ( cvar->engine_default.string ) {
		Cvar_CopyValueObject( &cvar->engine_default, out );
	} else if ( cvar->game_default.string ) {
		Cvar_CopyValueObject( &cvar->game_default, out );
	} else {
		Cvar_SetValueObject( out, "", CVAR_TRUSTED_CREATED );
	}
}

/*
=================
Cvar_Finalize

Generates cvar->s.string and other output values.
If value is being withheld due to active latch, it will go in cvar->s.latchedString.
=================
*/
static void Cvar_Finalize( localCvar_t *cvar, qboolean unlatch ) {
	char *old_string = NULL;
	char *old_latch = NULL;
	int old_flags = cvar->s.flags;
	cvarValue_t latched_value;
	Com_Memset( &latched_value, 0, sizeof( latched_value ) );

	// Save old values
	if ( cvar->s.string ) {
		Cvar_Linkstring( cvar->s.string, &old_string );
	}
	if ( cvar->s.latchedString ) {
		Cvar_Linkstring( cvar->s.latchedString, &old_latch );
	}

	// Update the reset string
	if ( cvar->engine_default.string ) {
		Cvar_Linkstring( cvar->engine_default.string, &cvar->s.resetString );
	} else if ( cvar->game_default.string ) {
		Cvar_Linkstring( cvar->game_default.string, &cvar->s.resetString );
	} else {
		Cvar_Copystring( "", &cvar->s.resetString );
	}
	Cvar_CheckRange2( cvar, &cvar->s.resetString, qtrue );

	// Determine latched value
	if ( cvar->temporary_value.string ) {
		Cvar_CopyValueObject( &cvar->temporary_value, &latched_value );
	} else if ( cvar->main_value.string ) {
		Cvar_CopyValueObject( &cvar->main_value, &latched_value );
	} else if ( cvar->game_default.string && ( cvar->engine_flags & CVAR_DEFER_TO_VM_DEFAULT ) ) {
		Cvar_CopyValueObject( &cvar->game_default, &latched_value );
	} else if ( cvar->engine_default.string ) {
		Cvar_CopyValueObject( &cvar->engine_default, &latched_value );
	} else if ( cvar->game_default.string ) {
		Cvar_CopyValueObject( &cvar->game_default, &latched_value );
	} else {
		Cvar_SetValueObject( &latched_value, "", CVAR_TRUSTED_CREATED );
	}
	Cvar_CheckRange2( cvar, &latched_value.string, qtrue );

	// Determine flags
	cvar->s.flags = cvar->temporary_flags | cvar->main_flags | cvar->engine_flags;
	if ( cvar->s.flags & CVAR_CREATED_FLAGS ) {
		// Shouldn't happen unless there is a cvar handling bug
		Com_Printf( "WARNING: Invalid created flags in cvar %s\n", cvar->s.name );
	}
	cvar->s.flags &= ~CVAR_CREATED_FLAGS;

	// Decide if we want to unlatch right away
	if ( unlatch || !( cvar->s.flags & CVAR_LATCH ) || latched_value.string == cvar->current_value.string ||
			( cvar->current_value.string && !strcmp( latched_value.string, cvar->current_value.string ) ) ) {
		// Perform the unlatch
		Cvar_CopyValueObject( &latched_value, &cvar->current_value );
		Cvar_ClearValueObject( &latched_value );
	}

	// Update output strings and flags
	Cvar_Linkstring( latched_value.string, &cvar->s.latchedString );
	if ( cvar->current_value.string ) {
		Cvar_Linkstring( cvar->current_value.string, &cvar->s.string );
		cvar->s.flags |= cvar->current_value.flags;
	} else {
		Cvar_Copystring( "", &cvar->s.string );
	}
	cvar_modifiedFlags |= cvar->s.flags ^ old_flags;

	// Check if new values are different from the old values
	if ( !old_string || strcmp( old_string, cvar->s.string ) ) {
		// Update modification trackers
		++cvar->s.modificationCount;
		cvar->s.modified = qtrue;
		cvar_modifiedFlags |= cvar->s.flags;

		// Update values
		cvar->s.value = atof( cvar->s.string );
		cvar->s.integer = atoi( cvar->s.string );
	}

	else if ( cvar->s.latchedString && ( !old_latch || strcmp( old_latch, cvar->s.latchedString ) ) ) {
		// "dedicated" cvar check in Com_Frame depends on modified being set due to latch change
		++cvar->s.modificationCount;
		cvar->s.modified = qtrue;
	}

	Cvar_MFree( old_string );
	Cvar_MFree( old_latch );
	Cvar_ClearValueObject( &latched_value );
}

/*
=================
Cvar_RestrictedModifiable

Returns qtrue if cvar is allowed to be modified from restricted mode.
Note any values set from restricted mode are temporary, regardless of what this function returns.
=================
*/
static qboolean Cvar_RestrictedModifiable( localCvar_t *cvar ) {
	if ( !( cvar->engine_flags & CVAR_ENGINE_REGISTERED ) ) {
		return qtrue;
	}
	if ( cvar->engine_flags & ( CVAR_RESTRICTED_MODIFIABLE | CVAR_SYSTEMINFO ) ) {
		return qtrue;
	}
	return qfalse;
}

/*
=================
Cvar_EngineRegister
=================
*/
static localCvar_t *Cvar_EngineRegister( const char *name, const char *value, int flags ) {
	localCvar_t *cvar = Cvar_FindOrCreate( name, qtrue );
	if ( !cvar ) {
		return NULL;
	}

	// Set value, unless a previous call set the override flag
	if ( value && !( cvar->engine_flags & CVAR_OVERRIDE_ENGINE_DEFAULT ) ) {
		Cvar_SetValueObject( &cvar->engine_default, value, CVAR_TRUSTED_CREATED );
	}

	// Set flags
	cvar->engine_flags |= flags | CVAR_ENGINE_REGISTERED;
	if ( cvar->engine_flags & CVAR_LATCH ) {
		cvar->temporary_flags &= ~CVAR_LATCH;
	}

	// If setting CVAR_ROM, wipe other values
	if ( flags & CVAR_ROM ) {
		Cvar_ClearValueObject( &cvar->main_value );
		Cvar_ClearValueObject( &cvar->temporary_value );
		Cvar_ClearValueObject( &cvar->game_default );
	}

	// If cvar is no longer restricted modifiable, wipe protected values
	if ( !Cvar_RestrictedModifiable( cvar ) ) {
		if ( !( cvar->temporary_value.flags & CVAR_TRUSTED_CREATED ) ) {
			Cvar_ClearValueObject( &cvar->temporary_value );
		}
		if ( !( cvar->game_default.flags & CVAR_TRUSTED_CREATED ) ) {
			Cvar_ClearValueObject( &cvar->game_default );
		}
	}

#ifdef CMOD_SAFE_AUTOEXEC
	// If cvar was set under restricted autoexec and CVAR_IMPORT_ALLOWED is not present, clear values
	if ( !( cvar->engine_flags & CVAR_IMPORT_ALLOWED ) ) {
		if ( cvar->temporary_value.flags & CVAR_RESTRICTED_AUTOEXEC_CREATED ) {
			Com_Printf( "Ignoring value set for %s due to restricted autoexec.\n", name );
			Cvar_ClearValueObject( &cvar->temporary_value );
		}
		if ( cvar->main_value.flags & CVAR_RESTRICTED_AUTOEXEC_CREATED ) {
			Com_Printf( "Ignoring value set for %s due to restricted autoexec.\n", name );
			Cvar_ClearValueObject( &cvar->main_value );
		}
	}
#endif

	Cvar_Finalize( cvar, qtrue );
	return cvar;
}

/*
=================
Cvar_EngineSet
=================
*/
static void Cvar_EngineSet( const char *name, const char *value ) {
	localCvar_t *cvar = Cvar_FindOrCreate( name, qtrue );
	if ( !cvar ) {
		return;
	}

	// Set main value
	Cvar_SetValueObject( &cvar->main_value, value, CVAR_TRUSTED_CREATED );

	// Wipe temporary value
	Cvar_ClearValueObject( &cvar->temporary_value );

	Cvar_Finalize( cvar, qtrue );
}

/*
=================
Cvar_CheckCommandPermissions

Returns qtrue if modifiable by commands, qfalse otherwise
=================
*/
static qboolean Cvar_CheckCommandPermissions( localCvar_t *cvar, qboolean init, qboolean verbose ) {
	if ( cvar->s.flags & CVAR_SERVER_CREATED ) {
		if ( verbose ) {
			Com_Printf( "%s is set by remote server.\n", cvar->s.name );
		}
		return qfalse;
	}
	if ( cvar->s.flags & CVAR_ROM ) {
		if ( verbose ) {
			Com_Printf( "%s is read only.\n", cvar->s.name );
		}
		return qfalse;
	}
	if ( cvar->s.flags & CVAR_INIT && !init ) {
		if ( verbose ) {
			Com_Printf( "%s can only be set as a command line parameter.\n", cvar->s.name );
		}
		return qfalse;
	}
	if ( ( cvar->s.flags & CVAR_CHEAT ) && sv_cheats && !sv_cheats->integer ) {
		if ( verbose ) {
			Com_Printf( "%s is cheat protected.\n", cvar->s.name );
		}
		return qfalse;
	}
	return qtrue;
}

/*
=================
Cvar_CommandSet

Handles user invoked set commands.
value may be NULL to set flags only.
=================
*/
void Cvar_CommandSet( const char *name, const char *value, int flags, cmd_mode_t mode, qboolean init, qboolean verbose ) {
	localCvar_t *cvar = Cvar_FindOrCreate( name, qtrue );
	if ( !cvar ) {
		return;
	}

	// Check for blocking conditions
	if ( !Cvar_CheckCommandPermissions( cvar, init, verbose ) ) {
		return;
	}

	if ( mode & CMD_PROTECTED ) {
		// In restricted mode, value and flags will be stored in temporary value slot.
		if ( !Cvar_RestrictedModifiable( cvar ) || ( cvar->main_flags & CVAR_PROTECTED ) ) {
			if ( verbose ) {
				Com_Printf( "%s cannot be set in restricted mode.\n", name );
			}
			return;
		}
		if ( value ) {
			Cvar_SetValueObject( &cvar->temporary_value, value, CVAR_USER_CREATED );
		}
		cvar->temporary_flags |= flags;
	} else {
		int valueFlags = CVAR_TRUSTED_CREATED | CVAR_USER_CREATED;

#ifdef CMOD_IMPORT_SETTINGS
		// Check for settings import mode
		if ( ( mode & CMD_SETTINGS_IMPORT ) && ( !( cvar->engine_flags & CVAR_IMPORT_ALLOWED ) ||
				( cvar->engine_default.string && value && !strcmp( cvar->engine_default.string, value ) ) ) ) {
			if ( CVAR_DEBUG ) {
				Com_Printf( "Not modifying %s due to settings import mode.\n", name );
			}
			return;
		}
#endif

#ifdef CMOD_SAFE_AUTOEXEC
		// Check for safe autoexec.cfg mode
		if ( mode & CMD_RESTRICTED_AUTOEXEC ) {
			if ( cvar->engine_flags & CVAR_ENGINE_REGISTERED && !( cvar->engine_flags & CVAR_IMPORT_ALLOWED ) ) {
				Com_Printf( "Not modifying %s due to restricted autoexec.\n", name );
				return;
			}

			// Set created flag, so if the engine registers the cvar later we can re-check if the value is allowed
			valueFlags |= CVAR_RESTRICTED_AUTOEXEC_CREATED;
		}
#endif

		if ( value ) {
			Cvar_SetValueObject( &cvar->main_value, value, valueFlags );
			Cvar_ClearValueObject( &cvar->temporary_value );
		}
		cvar->main_flags |= flags;
	}

	Cvar_Finalize( cvar, qfalse );

	// Print message if latch is blocking the new value from being activated
	if ( value && verbose && cvar->s.latchedString ) {
		Com_Printf( "%s will be changed upon restarting.\n", name );
	}
}

/*
=================
Cvar_CommandReset

Handle user-invoked cvar reset.
=================
*/
static void Cvar_CommandReset( localCvar_t *cvar, qboolean clear_flags, qboolean set_empty, qboolean verbose ) {
	if ( !Cvar_CheckCommandPermissions( cvar, qfalse, verbose ) ) {
		return;
	}

	Cvar_ClearValueObject( &cvar->main_value );
	Cvar_ClearValueObject( &cvar->temporary_value );

	if ( clear_flags ) {
		cvar->main_flags = 0;
		cvar->temporary_flags = 0;
	}

	if ( set_empty ) {
		Cvar_SetValueObject( &cvar->main_value, "", CVAR_USER_CREATED | CVAR_TRUSTED_CREATED );
	}

	Cvar_Finalize( cvar, qfalse );
}

/*
=================
Cvar_GameCvarRegister
=================
*/
static localCvar_t *Cvar_GameCvarRegister( const char *name, const char *value, int flags, int valueFlags ) {
	localCvar_t *cvar = Cvar_FindOrCreate( name, qtrue );
	if ( !cvar ) {
		return NULL;
	}

	if ( !( valueFlags & CVAR_TRUSTED_CREATED ) && !Cvar_RestrictedModifiable( cvar ) ) {
		if ( CVAR_DEBUG ) {
			Com_Printf( "Cvar_GameCvarRegister blocked modification of %s\n", name );
		}
		return cvar;
	}

	Cvar_SetValueObject( &cvar->game_default, value, valueFlags );

	// Set flags
	if ( cvar->engine_flags & CVAR_IGNORE_VM_CHEAT_PROTECT ) {
		flags &= ~CVAR_CHEAT;
	}
	// Allow any VM, even restricted, to set the archive flag on non-engine cvars
	// Value should normally only be written if it is set by the user in console
	if ( !( cvar->engine_flags & CVAR_ENGINE_REGISTERED ) ) {
		cvar->main_flags |= flags & CVAR_ARCHIVE;
	}
	cvar->temporary_flags |= flags & ( CVAR_USERINFO | CVAR_SERVERINFO | CVAR_SYSTEMINFO |
			CVAR_LATCH | CVAR_ROM | CVAR_CHEAT | CVAR_NORESTART );

	// If setting CVAR_ROM, override user value
	if ( ( cvar->temporary_flags & CVAR_ROM ) && !( flags & CVAR_INIT ) && cvar->game_default.string &&
			( ( cvar->temporary_value.string ? cvar->temporary_flags : cvar->main_flags ) & CVAR_USER_CREATED ) ) {
		Cvar_CopyValueObject( &cvar->game_default, &cvar->temporary_value );
	}

	Cvar_Finalize( cvar, !( cvar->engine_flags & CVAR_LATCH ) );
	return cvar;
}

/*
=================
Cvar_GameCvarSet

Called for both VM and systeminfo set calls.
=================
*/
static void Cvar_GameCvarSet( const char *name, const char *value, int flags, int valueFlags ) {
	localCvar_t *cvar = Cvar_FindOrCreate( name, qtrue );
	if ( !cvar ) {
		return;
	}

	if ( !( valueFlags & CVAR_TRUSTED_CREATED ) && !Cvar_RestrictedModifiable( cvar ) ) {
		if ( CVAR_DEBUG ) {
			Com_Printf( "Cvar_GameCvarSet blocked modification of %s\n", name );
		}
		return;
	}

	if ( !( valueFlags & CVAR_TRUSTED_CREATED ) || !( cvar->engine_flags & CVAR_VM_PERSISTENT ) ) {
		Cvar_SetValueObject( &cvar->temporary_value, value, valueFlags );
		cvar->temporary_flags |= flags;
	}

	else {
		Cvar_SetValueObject( &cvar->main_value, value, valueFlags );
		cvar->main_flags |= flags;
		Cvar_ClearValueObject( &cvar->temporary_value );
	}

	Cvar_Finalize( cvar, !( cvar->engine_flags & CVAR_LATCH ) );
}

/*
=================
Cvar_CheckRange
=================
*/
void Cvar_CheckRange( cvar_t *var, float min, float max, qboolean integral ) {
	localCvar_t *cvar = (localCvar_t *)var;

	// Record the range parameters
	cvar->validate = qtrue;
	cvar->min = min;
	cvar->max = max;
	cvar->integral = integral;

	Cvar_Finalize( cvar, qtrue );
}

/*
=================
Cvar_SetCheatState

Set default value on cheat cvars
=================
*/
void Cvar_SetCheatState( void ) {
	localCvar_t *cvar;
	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		if ( ( cvar->s.flags & CVAR_CHEAT ) && !( cvar->s.flags & CVAR_VM_CREATED ) ) {
			Cvar_CopyDefaultToValueObject( cvar, &cvar->temporary_value );
			Cvar_Finalize( cvar, qfalse );
		}
	}
}

/*
=================
Cvar_SetDescription
=================
*/
void Cvar_SetDescription( cvar_t *var, const char *var_description ) {
	localCvar_t *cvar = (localCvar_t *)var;
	Cvar_Copystring( var_description, &cvar->description );
}

/*
=================
Cvar_EndSession

Reset temporary values when disconnecting from remote server.
=================
*/
void Cvar_EndSession( void ) {
	localCvar_t *cvar;
	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		if ( cvar->game_default.string || cvar->temporary_value.string || cvar->temporary_flags ) {
			// Clear all temporary values
			Cvar_ClearValueObject( &cvar->game_default );
			Cvar_ClearValueObject( &cvar->temporary_value );
			cvar->temporary_flags = 0;
			Cvar_Finalize( cvar, qfalse );
		}
	}
}

/*
###############################################################################################

Additional Cvar Modifiers

###############################################################################################
*/

/*
=================
Cvar_Get

Called by engine code. VM calls should use Cvar_Register instead.
=================
*/
cvar_t *Cvar_Get( const char *var_name, const char *var_value, int flags ) {
	return &Cvar_EngineRegister( var_name, var_value, flags )->s;
}

/*
=================
Cvar_Set2

Called in a single place in engine code.
=================
*/
cvar_t *Cvar_Set2( const char *var_name, const char *value, qboolean force ) {
	Cvar_EngineSet( var_name, value );
	return 0;
}

/*
=================
Cvar_StartupSet

Used for loading startup variables from the command line.
=================
*/
void Cvar_StartupSet( const char *var_name, const char *value ) {
	Cvar_CommandSet( var_name, value, 0, CMD_NORMAL, qtrue, qtrue );
}

/*
=================
Cvar_SystemInfoSet
=================
*/
void Cvar_SystemInfoSet( const char *var_name, const char *value ) {
	Cvar_GameCvarSet( var_name, value, CVAR_ROM, CVAR_SERVER_CREATED );
}

/*
=================
Cvar_Set

Called by engine code.
=================
*/
void Cvar_Set( const char *var_name, const char *value ) {
	Cvar_EngineSet( var_name, value );
}

/*
=================
Cvar_SetValue

Called by engine code.
=================
*/
void Cvar_SetValue( const char *var_name, float value ) {
	char val[32];

	if ( value == (int)value ) {
		Com_sprintf( val, sizeof( val ), "%i", (int)value );
	} else {
		Com_sprintf( val, sizeof( val ), "%f", value );
	}
	Cvar_Set( var_name, val );
}

/*
=================
Cvar_SetLatched

Called in a single place in engine code.
=================
*/
void Cvar_SetLatched( const char *var_name, const char *value ) {
	Cvar_EngineSet( var_name, value );
}

/*
=================
Cvar_SetSafe

Called from VMs.
=================
*/
void Cvar_SetSafe( const char *var_name, const char *value, qboolean trusted ) {
	int trustedFlag = trusted ? CVAR_TRUSTED_CREATED : 0;
	Cvar_GameCvarSet( var_name, value, 0, CVAR_VM_CREATED | trustedFlag );
}

/*
=================
Cvar_SetValueSafe

Called from VMs.
=================
*/
void Cvar_SetValueSafe( const char *var_name, float value, qboolean trusted ) {
	char val[32];

	if ( Q_isintegral( value ) ) {
		Com_sprintf( val, sizeof( val ), "%i", (int)value );
	} else {
		Com_sprintf( val, sizeof( val ), "%f", value );
	}
	Cvar_SetSafe( var_name, val, trusted );
}

/*
=================
Cvar_Reset

Called through a UI VM call.
=================
*/
void Cvar_Reset( const char *var_name ) {
	qboolean trusted = VMPermissions_CheckTrusted( VM_UI );
	localCvar_t *cvar = Cvar_FindOrCreate( var_name, qfalse );
	if ( !cvar ) {
		return;
	}
	if ( !trusted && !Cvar_RestrictedModifiable( cvar ) ) {
		return;
	}
	if ( !trusted || !( cvar->engine_flags & CVAR_VM_PERSISTENT ) ) {
		Cvar_CopyDefaultToValueObject( cvar, &cvar->temporary_value );
	} else {
		Cvar_ClearValueObject( &cvar->main_value );
		Cvar_ClearValueObject( &cvar->temporary_value );
	}
	Cvar_Finalize( cvar, qfalse );
}

/*
=================
Cvar_ForceReset

Called in a couple places in engine code.
=================
*/
void Cvar_ForceReset( const char *var_name ) {
	localCvar_t *cvar = Cvar_FindOrCreate( var_name, qfalse );
	if ( !cvar ) {
		return;
	}
	Cvar_ClearValueObject( &cvar->main_value );
	Cvar_ClearValueObject( &cvar->temporary_value );
	Cvar_Finalize( cvar, qtrue );
}

/*
=================
Cvar_Restart

This is currently only called from Com_GameRestart.
=================
*/
void Cvar_Restart( qboolean unsetVM ) {
	localCvar_t *cvar;
	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		if ( ( cvar->main_flags & CVAR_USER_CREATED ) || ( unsetVM && ( cvar->main_flags & CVAR_VM_CREATED ) ) ) {
			Cvar_ClearValueObject( &cvar->main_value );
			cvar->main_flags = 0;
		}
		if ( ( cvar->temporary_flags & CVAR_USER_CREATED ) || ( unsetVM && ( cvar->temporary_flags & CVAR_VM_CREATED ) ) ) {
			Cvar_ClearValueObject( &cvar->temporary_value );
			Cvar_ClearValueObject( &cvar->game_default );
			cvar->temporary_flags = 0;
		}
		Cvar_Finalize( cvar, qtrue );
	}
}

/*
###############################################################################################

Cvar Accessors

###############################################################################################
*/

/*
=================
Cvar_VariableValue
=================
*/
float Cvar_VariableValue( const char *var_name ) {
	localCvar_t *cvar = Cvar_FindOrCreate( var_name, qfalse );
	if ( !cvar ) {
		return 0.0f;
	}
	return cvar->s.value;
}

/*
=================
Cvar_VariableIntegerValue
=================
*/
int Cvar_VariableIntegerValue( const char *var_name ) {
	localCvar_t *cvar = Cvar_FindOrCreate( var_name, qfalse );
	if ( !cvar ) {
		return 0;
	}
	return cvar->s.integer;
}

/*
=================
Cvar_VariableString

Result should not be modified or freed by caller.
=================
*/
char *Cvar_VariableString( const char *var_name ) {
	localCvar_t *cvar = Cvar_FindOrCreate( var_name, qfalse );
	if ( !cvar ) {
		return "";
	}
	return cvar->s.string;
}

/*
=================
Cvar_VariableStringBuffer
=================
*/
void Cvar_VariableStringBuffer( const char *var_name, char *buffer, int bufsize ) {
	Q_strncpyz( buffer, Cvar_VariableString( var_name ), bufsize );
}

/*
=================
Cvar_Flags
=================
*/
int Cvar_Flags( const char *var_name ) {
	localCvar_t *cvar = Cvar_FindOrCreate( var_name, qfalse );
	if ( !cvar ) {
		return CVAR_NONEXISTENT;
	}
	if ( cvar->s.modified ) {
		return cvar->s.flags | CVAR_MODIFIED;
	}
	return cvar->s.flags;
}

/*
=================
Cvar_CommandCompletion
=================
*/
void Cvar_CommandCompletion( void ( *callback )( const char *s ) ) {
	localCvar_t *cvar;
	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		callback( cvar->s.name );
	}
}

/*
=================
Cvar_InfoString
=================
*/
char *Cvar_InfoString( int bit ) {
	static char info[MAX_INFO_STRING];
	localCvar_t *cvar;

	info[0] = '\0';

	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		if ( cvar->s.name && ( cvar->s.flags & bit ) ) {
			Info_SetValueForKey( info, cvar->s.name, cvar->s.string );
		}
	}

	return info;
}

/*
=================
Cvar_InfoString_Big
=================
*/
char *Cvar_InfoString_Big( int bit ) {
	static char info[BIG_INFO_STRING];
	localCvar_t *cvar;

	info[0] = '\0';

	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		if ( cvar->s.name && ( cvar->s.flags & bit ) ) {
			Info_SetValueForKey_Big( info, cvar->s.name, cvar->s.string );
		}
	}

	return info;
}

/*
=================
Cvar_InfoStringBuffer
=================
*/
void Cvar_InfoStringBuffer( int bit, char *buff, int buffsize ) {
	Q_strncpyz( buff, Cvar_InfoString( bit ), buffsize );
}

/*
=================
Cvar_Print
=================
*/
void Cvar_Print( localCvar_t *cvar ) {
	char data[MAXPRINTMSG];
	cvar_stream_t stream = { data, 0, sizeof( data ), qfalse };

	ADD_TEXT( "\"" );
	ADD_TEXT( cvar->s.name );
	ADD_TEXT( "\" is:\"" );
	ADD_TEXT( cvar->s.string );
	ADD_TEXT( "^7\"" );
	if ( *cvar->s.resetString ) {
		if ( !Q_stricmp( cvar->s.string, cvar->s.resetString ) ) {
			ADD_TEXT( ", the default\n" );
		} else {
			ADD_TEXT( " default:\"" );
			ADD_TEXT( cvar->s.resetString );
			ADD_TEXT( "\"\n" );
		}
	} else {
		ADD_TEXT( "\n" );
	}

	if ( cvar->s.latchedString ) {
		ADD_TEXT( "latched: \"" );
		ADD_TEXT( cvar->s.latchedString );
		ADD_TEXT( "\"\n" );
	}

	if ( cvar->description ) {
		ADD_TEXT( cvar->description );
		ADD_TEXT( "\n" );
	}

	Com_Printf( "%s", stream.data );
}

/*
###############################################################################################

VM Access

###############################################################################################
*/

#define CVAR_MAX_VM_HANDLES 2048
static localCvar_t *cvar_handles[CVAR_MAX_VM_HANDLES];
static int cvar_handle_count = 0;

/*
=================
Cvar_Update
=================
*/
void Cvar_Update( vmCvar_t *vmCvar ) {
	int index = vmCvar->handle - 1;
	localCvar_t *cvar;

	if ( index < 0 || index >= cvar_handle_count ) {
		Com_Error( ERR_DROP, "Cvar_Update on invalid handle" );
	}
	cvar = cvar_handles[index];

	if ( cvar->s.modificationCount == vmCvar->modificationCount ) {
		return;
	}

	vmCvar->modificationCount = cvar->s.modificationCount;
	Q_strncpyz( vmCvar->string, cvar->s.string, MAX_CVAR_VALUE_STRING );
	vmCvar->value = cvar->s.value;
	vmCvar->integer = cvar->s.integer;
}

/*
=================
Cvar_Register
=================
*/
void Cvar_Register( vmCvar_t *vmCvar, const char *varName, const char *defaultValue, int flags, qboolean trusted ) {
	int trustedFlag = trusted ? CVAR_TRUSTED_CREATED : 0;
	localCvar_t *cvar = Cvar_GameCvarRegister( varName, defaultValue, flags, CVAR_VM_CREATED | trustedFlag );
	if ( !cvar || !vmCvar ) {
		return;
	}

	if ( !cvar->vm_handle ) {
		if ( cvar_handle_count >= CVAR_MAX_VM_HANDLES ) {
			Com_Error( ERR_FATAL, "CVAR_MAX_VM_HANDLES hit" );
		} else {
			cvar_handles[cvar_handle_count] = cvar;
			cvar->vm_handle = cvar_handle_count + 1;
			++cvar_handle_count;
		}
	}

	vmCvar->handle = cvar->vm_handle;
	vmCvar->modificationCount = -1; // Immediately update in Cvar_Update
	Cvar_Update( vmCvar );
}

/*
###############################################################################################

Commands

###############################################################################################
*/

/*
=================
Cvar_Print_f
=================
*/
void Cvar_Print_f( void ) {
	char *name;
	localCvar_t *cvar;

	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "usage: print <variable>\n" );
		return;
	}

	name = Cmd_Argv( 1 );

	cvar = Cvar_FindOrCreate( name, qfalse );

	if ( cvar ) {
		Cvar_Print( cvar );
	} else {
		Com_Printf( "Cvar %s does not exist.\n", name );
	}
}

/*
=================
Cvar_Command
=================
*/
qboolean Cvar_Command( cmd_mode_t mode ) {
	localCvar_t *cvar = Cvar_FindOrCreate( Cmd_Argv( 0 ), qfalse );
	if ( !cvar ) {
		return qfalse;
	}

	// perform a variable print or set
	if ( Cmd_Argc() == 1 ) {
		Cvar_Print( cvar );
		return qtrue;
	}

	// perform the same set as in Cvar_Set_Command
	Cvar_CommandSet( cvar->s.name, Cmd_Args(), 0, mode, qfalse, qtrue );
	return qtrue;
}

/*
=================
Cvar_Vstr
=================
*/
void Cvar_Vstr( cmd_mode_t mode ) {
	localCvar_t *cvar;
	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "vstr <variablename> : execute a variable command\n" );
		return;
	}

	cvar = Cvar_FindOrCreate( Cmd_Argv( 1 ), qfalse );
	if ( !cvar ) {
		return;
	}

	if ( !( cvar->s.flags & CVAR_TRUSTED_CREATED ) ) {
		mode |= CMD_PROTECTED;
	} else if ( !Q_stricmp( cvar->s.name, "fs_game" ) ) {
		mode |= CMD_PROTECTED;
	}

	Cbuf_ExecuteTextByMode( EXEC_INSERT, cvar->s.string, mode );
}

/*
=================
Cvar_CompleteCvarName
=================
*/
void Cvar_CompleteCvarName( char *args, int argNum ) {
	if ( argNum == 2 ) {
		// Skip "<cmd> "
		char *p = Com_SkipTokens( args, 1, " " );

		if ( p > args ) {
			Field_CompleteCommand( p, qfalse, qtrue );
		}
	}
}

/*
=================
Cvar_FlagSetCommand
=================
*/
static void Cvar_FlagSetCommand( cmd_mode_t mode, const char *cvar_name, const char *value, char *flag_string ) {
	int flags = 0;
	while ( *flag_string ) {
		char flag = tolower( *flag_string );
		if ( flag == 'a' )
			flags |= CVAR_ARCHIVE;
		if ( flag == 'u' )
			flags |= CVAR_USERINFO;
		if ( flag == 's' )
			flags |= CVAR_SERVERINFO;
		if ( flag == 'r' )
			flags |= CVAR_ROM;
		if ( flag == 'v' )
			flags |= CVAR_PROTECTED;
		if ( flag == 'n' )
			flags |= CVAR_NORESTART;
		++flag_string;
	}
	Cvar_CommandSet( cvar_name, value, flags, mode, qfalse, qtrue );
}

/*
=================
Cvar_Setf_f
=================
*/
static void Cvar_Setf_f( void ) {
	int c = Cmd_Argc();
	char *cmd = Cmd_Argv( 0 );

	if ( c < 3 ) {
		Com_Printf( "usage: %s <variable> <flags>\n", cmd );
		return;
	}

	Cvar_FlagSetCommand( CMD_NORMAL, Cmd_Argv( 1 ), NULL, Cmd_Argv( 2 ) );
}

/*
=================
Cvar_Set_f
=================
*/
static void Cvar_Set_f( cmd_mode_t mode ) {
	int c = Cmd_Argc();
	char *cmd = Cmd_Argv( 0 );

	if ( c < 2 ) {
		Com_Printf( "usage: %s <variable> <value>\n", cmd );
		return;
	}
	if ( c == 2 ) {
		Cvar_Print_f();
		return;
	}

	if ( !cmd[0] || !cmd[1] || !cmd[2] ) {
		return; // Shouldn't happen
	}

	Cvar_FlagSetCommand( mode, Cmd_Argv( 1 ), Cmd_ArgsFrom( 2 ), cmd + 3 );
}

/*
=================
Cvar_List_f
=================
*/
static void Cvar_List_f( void ) {
	localCvar_t *cvar;
	int cvar_count = 0;
	char *match;

	if ( Cmd_Argc() > 1 ) {
		match = Cmd_Argv( 1 );
	} else {
		match = NULL;
	}

	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		++cvar_count;

		if ( match && !Com_Filter( match, cvar->s.name, qfalse ) ) {
			continue;
		}

		if ( cvar->s.flags & CVAR_SERVERINFO ) {
			Com_Printf( "S" );
		} else {
			Com_Printf( " " );
		}
		if ( cvar->s.flags & CVAR_SYSTEMINFO ) {
			Com_Printf( "s" );
		} else {
			Com_Printf( " " );
		}
		if ( cvar->s.flags & CVAR_USERINFO ) {
			Com_Printf( "U" );
		} else {
			Com_Printf( " " );
		}
		if ( cvar->s.flags & CVAR_ROM ) {
			Com_Printf( "R" );
		} else {
			Com_Printf( " " );
		}
		if ( cvar->s.flags & CVAR_INIT ) {
			Com_Printf( "I" );
		} else {
			Com_Printf( " " );
		}
		if ( cvar->s.flags & CVAR_ARCHIVE ) {
			Com_Printf( "A" );
		} else {
			Com_Printf( " " );
		}
		if ( cvar->s.flags & CVAR_LATCH ) {
			Com_Printf( "L" );
		} else {
			Com_Printf( " " );
		}
		if ( cvar->s.flags & CVAR_CHEAT ) {
			Com_Printf( "C" );
		} else {
			Com_Printf( " " );
		}
		if ( cvar->s.flags & CVAR_USER_CREATED ) {
			Com_Printf( "?" );
		} else {
			Com_Printf( " " );
		}

		Com_Printf( " %s \"%s\"\n", cvar->s.name, cvar->s.string );
	}

	Com_Printf( "\n%i total cvars\n", cvar_count );
	Com_Printf( "%i VM indexes\n", cvar_handle_count );
}

/*
=================
Cvar_Toggle_f
=================
*/
static void Cvar_Toggle_f( cmd_mode_t mode ) {
	int i, c = Cmd_Argc();
	char *curval;

	if ( c < 2 ) {
		Com_Printf( "usage: toggle <variable> [value1, value2, ...]\n" );
		return;
	}

	if ( c == 2 ) {
		Cvar_CommandSet( Cmd_Argv( 1 ), va( "%d", !Cvar_VariableValue( Cmd_Argv( 1 ) ) ), 0, mode, qfalse, qtrue );
		return;
	}

	if ( c == 3 ) {
		Com_Printf( "toggle: nothing to toggle to\n" );
		return;
	}

	curval = Cvar_VariableString( Cmd_Argv( 1 ) );

	// don't bother checking the last arg for a match since the desired
	// behaviour is the same as no match (set to the first argument)
	for ( i = 2; i + 1 < c; i++ ) {
		if ( strcmp( curval, Cmd_Argv( i ) ) == 0 ) {
			Cvar_CommandSet( Cmd_Argv( 1 ), Cmd_Argv( i + 1 ), 0, mode, qfalse, qtrue );
			return;
		}
	}

	// fallback
	Cvar_CommandSet( Cmd_Argv( 1 ), Cmd_Argv( 2 ), 0, mode, qfalse, qtrue );
}

/*
=================
Cvar_Reset_f
=================
*/
static void Cvar_Reset_f( void ) {
	localCvar_t *cvar;
	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "usage: reset <variable>\n" );
		return;
	}

	cvar = Cvar_FindOrCreate( Cmd_Argv( 1 ), qfalse );
	if ( cvar ) {
		Cvar_CommandReset( cvar, qfalse, qfalse, qtrue );
	}
}

/*
=================
Cvar_Unset_f
=================
*/
static void Cvar_Unset_f( void ) {
	localCvar_t *cvar;
	if ( Cmd_Argc() != 2 ) {
		Com_Printf( "usage: unset <variable>\n" );
		return;
	}

	cvar = Cvar_FindOrCreate( Cmd_Argv( 1 ), qfalse );
	if ( cvar ) {
		Cvar_CommandReset( cvar, qtrue, qtrue, qtrue );
	}
}

/*
=================
Cvar_Restart_f
=================
*/
static void Cvar_Restart_f( void ) {
	localCvar_t *cvar;
	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		if ( cvar->s.flags & CVAR_NORESTART ) {
			continue;
		}
		Cvar_CommandReset( cvar, qtrue, qfalse, qfalse );
	}
}

/*
=================
Cvar_FlagsToStream
=================
*/
static void Cvar_FlagsToStream(int flags, cvar_stream_t *stream) {
	int have_flag = 0;
	#define RUN_FLAG(flag) if ( flags & flag ) { if ( have_flag ) ADD_TEXT2 ( ", " ); else have_flag = 1; ADD_TEXT2( #flag ); }
	RUN_FLAG( CVAR_ARCHIVE );
	RUN_FLAG( CVAR_USERINFO );
	RUN_FLAG( CVAR_SERVERINFO );
	RUN_FLAG( CVAR_SYSTEMINFO );
	RUN_FLAG( CVAR_INIT );
	RUN_FLAG( CVAR_LATCH );
	RUN_FLAG( CVAR_ROM );
	RUN_FLAG( CVAR_USER_CREATED );
	RUN_FLAG( CVAR_TEMP );
	RUN_FLAG( CVAR_CHEAT );
	RUN_FLAG( CVAR_NORESTART );
	RUN_FLAG( CVAR_SERVER_CREATED );
	RUN_FLAG( CVAR_VM_CREATED );
	RUN_FLAG( CVAR_PROTECTED );
	RUN_FLAG( CVAR_ENGINE_REGISTERED );
	RUN_FLAG( CVAR_TRUSTED_CREATED );
	RUN_FLAG( CVAR_RESTRICTED_MODIFIABLE );
	RUN_FLAG( CVAR_VM_PERSISTENT );
	RUN_FLAG( CVAR_OVERRIDE_ENGINE_DEFAULT );
	RUN_FLAG( CVAR_IMPORT_ALLOWED );
	RUN_FLAG( CVAR_DEFER_TO_VM_DEFAULT );
	RUN_FLAG( CVAR_NOARCHIVE );
	RUN_FLAG( CVAR_NUMERIC );
	RUN_FLAG( CVAR_IGNORE_VM_CHEAT_PROTECT );
#ifdef CMOD_SAFE_AUTOEXEC
	RUN_FLAG( CVAR_RESTRICTED_AUTOEXEC_CREATED );
#endif
	if ( !have_flag ) {
		ADD_TEXT2( "<None>" );
	}
}

/*
=================
Cvar_Var_f
=================
*/
static void Cvar_Var_f(void) {
	localCvar_t *cvar = Cvar_FindOrCreate( Cmd_Argv( 1 ), qfalse );
	char data[1000];
	cvar_stream_t stream = { data, 0, sizeof( data ), qfalse };

	if ( !cvar ) {
		Com_Printf( "Variable not found.\n" );
		return;
	}

	ADD_TEXT( "variable name: " ); ADD_TEXT( cvar->s.name); ADD_TEXT( "\n" );
	ADD_TEXT( "working value: " ); ADD_TEXT( cvar->s.string ); ADD_TEXT( "\n" );
	ADD_TEXT( "working flags: " ); Cvar_FlagsToStream( cvar->s.flags, &stream ); ADD_TEXT( "\n" );
	ADD_TEXT( "latch value: " ); ADD_TEXT( cvar->s.latchedString ? cvar->s.latchedString : "<None>" ); ADD_TEXT( "\n\n" );

	ADD_TEXT( "engine default: " ); ADD_TEXT( cvar->engine_default.string ? cvar->engine_default.string : "<None>" ); ADD_TEXT( "\n" );
	ADD_TEXT( "game default: " ); ADD_TEXT( cvar->game_default.string ? cvar->game_default.string : "<None>" ); ADD_TEXT( "\n" );
	ADD_TEXT( "main value: " ); ADD_TEXT( cvar->main_value.string ? cvar->main_value.string : "<None>" ); ADD_TEXT( "\n" );
	ADD_TEXT( "temporary value: " ); ADD_TEXT( cvar->temporary_value.string ? cvar->temporary_value.string : "<None>" ); ADD_TEXT( "\n\n" );

	ADD_TEXT( "engine flags: " ); Cvar_FlagsToStream( cvar->engine_flags, &stream ); ADD_TEXT( "\n" );
	ADD_TEXT( "main flags: " ); Cvar_FlagsToStream( cvar->main_flags, &stream ); ADD_TEXT( "\n" );
	ADD_TEXT( "temporary flags: " ); Cvar_FlagsToStream( cvar->temporary_flags, &stream ); ADD_TEXT( "\n" );
	if ( cvar->engine_default.string ) {
		ADD_TEXT( "origin flags (engine default): " ); Cvar_FlagsToStream( cvar->engine_default.flags, &stream ); ADD_TEXT( "\n" );
	}
	if ( cvar->game_default.string ) {
		ADD_TEXT( "origin flags (game default): " ); Cvar_FlagsToStream( cvar->game_default.flags, &stream ); ADD_TEXT( "\n" );
	}
	if ( cvar->main_value.string ) {
		ADD_TEXT( "origin flags (main value): " ); Cvar_FlagsToStream( cvar->main_value.flags, &stream ); ADD_TEXT( "\n" );
	}
	if ( cvar->temporary_value.string ) {
		ADD_TEXT( "origin flags (temporary value): " ); Cvar_FlagsToStream( cvar->temporary_value.flags, &stream ); ADD_TEXT( "\n" );
	}
	if ( cvar->current_value.string ) {
		ADD_TEXT( "origin flags (current value): " ); Cvar_FlagsToStream( cvar->current_value.flags, &stream ); ADD_TEXT( "\n" );
	}

	Com_Printf( "%s", stream.data );
}

/*
###############################################################################################

Special Cvars

###############################################################################################
*/

typedef enum {
	CVARTYPE_NONE,
	CVARTYPE_PREFERENCES,
	CVARTYPE_GRAPHICS,
	CVARTYPE_SOUND,
	CVARTYPE_NETWORK,
	CVARTYPE_MENU,
	CVARTYPE_LAST
} cvar_category_t;

typedef struct {
	char *cvar_name;
	char *default_value;
	cvar_category_t category;
	int flags;
} special_cvar_t;

// Allows untrusted VMs to modify the setting temporarily, and trusted VMs to modify it persistently
#define FLAGS_PERSISTENT ( CVAR_OVERRIDE_ENGINE_DEFAULT | CVAR_RESTRICTED_MODIFIABLE | CVAR_VM_PERSISTENT | CVAR_ARCHIVE )

// Allows untrusted and trusted VMs to modify the setting temporarily
#define FLAGS_NORMAL ( CVAR_OVERRIDE_ENGINE_DEFAULT | CVAR_RESTRICTED_MODIFIABLE )

// Blocks untrusted VMs from modifying the setting altogether
#define FLAGS_RESTRICTED ( CVAR_OVERRIDE_ENGINE_DEFAULT )

const special_cvar_t specials[] = {
	// Special cvars and defaults
	{ "ui_cdkeychecked", "1", CVARTYPE_NONE, FLAGS_NORMAL | CVAR_NOARCHIVE },
	{ "ui_cdkeychecked2", "1", CVARTYPE_NONE, FLAGS_NORMAL | CVAR_NOARCHIVE },
	{ "cl_motd", "0", CVARTYPE_NONE, FLAGS_RESTRICTED },
	{ "com_hunkmegs", "256", CVARTYPE_NONE, FLAGS_RESTRICTED },
	{ "com_zoneMegs", "128", CVARTYPE_NONE, FLAGS_RESTRICTED },
	{ "com_soundMegs", "32", CVARTYPE_NONE, FLAGS_RESTRICTED },
	{ "s_sdlSpeed", "44100", CVARTYPE_NONE, FLAGS_RESTRICTED },
	{ "com_altivec", "0", CVARTYPE_NONE, FLAGS_RESTRICTED },
	{ "sv_master1", "master.stef1.ravensoft.com", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_master2", "master.stvef.org", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_master3", "efmaster.tjps.eu", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_master4", "master.stef1.daggolin.de", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_master5", "", CVARTYPE_NONE, FLAGS_NORMAL },
#ifdef DEDICATED
	{ "dedicated", "1", CVARTYPE_NONE, FLAGS_NORMAL | CVAR_NOARCHIVE },
#else
	{ "dedicated", "0", CVARTYPE_NONE, FLAGS_NORMAL | CVAR_NOARCHIVE },
#endif
	{ "fs_game", "", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "fs_download_mode", "1", CVARTYPE_NONE, FLAGS_RESTRICTED },
	{ "sv_killserver", "", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cmod_crosshair_enable", "1", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_hostname", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cl_serverStatusResendTime", "500", CVARTYPE_NONE, FLAGS_RESTRICTED },
	{ "cg_aspectCorrectGunPos", "-1", CVARTYPE_NONE, FLAGS_NORMAL | CVAR_ARCHIVE },
	{ "ui_aspectCorrect", "-1", CVARTYPE_NONE, FLAGS_NORMAL | CVAR_ARCHIVE },
	{ "cg_gunX", NULL, CVARTYPE_NONE, FLAGS_NORMAL | CVAR_IGNORE_VM_CHEAT_PROTECT },
	{ "cg_gunY", NULL, CVARTYPE_NONE, FLAGS_NORMAL | CVAR_IGNORE_VM_CHEAT_PROTECT },
	{ "cg_gunZ", NULL, CVARTYPE_NONE, FLAGS_NORMAL | CVAR_IGNORE_VM_CHEAT_PROTECT },
	{ "cg_viewsize", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "fraglimit", NULL, CVARTYPE_NONE, FLAGS_NORMAL | CVAR_DEFER_TO_VM_DEFAULT },
	{ "g_gametype", NULL, CVARTYPE_NONE, FLAGS_NORMAL | CVAR_DEFER_TO_VM_DEFAULT },
	{ "rconPassword", "", CVARTYPE_NONE, FLAGS_NORMAL | CVAR_IMPORT_ALLOWED },

	// Server settings
	{ "nextmap", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_pure", "0", CVARTYPE_NONE, FLAGS_NORMAL | CVAR_SERVERINFO },
	{ "sv_minRate", "25000", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_fps", "30", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_voip", "0", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "sv_maxclients", "32", CVARTYPE_NONE, FLAGS_NORMAL },
	{ "g_teamForceBalance", "0", CVARTYPE_NONE, FLAGS_NORMAL },

	// Preferences
	{ "name", "RedShirt", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_IMPORT_ALLOWED },
	{ "model", "munro/red", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_IMPORT_ALLOWED },
	{ "cl_allowDownload", "1", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "sensitivity", "5", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_IMPORT_ALLOWED | CVAR_NUMERIC },
	{ "in_mouse_warping", "0", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "g_language", "ENGLISH", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_IMPORT_ALLOWED },
	{ "s_language", "ENGLISH", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_IMPORT_ALLOWED },
	{ "cg_crosshairSize", "24", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_IMPORT_ALLOWED },
	{ "cmod_crosshair_selection", "076b9707", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_drawFPS", "0", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_drawTeamOverlay", "0", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_drawTimer", "1", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_lagometer", "0", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_marks", "1", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_simpleItems", "0", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_forceModel", "0", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_drawGun", "1", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cg_bobup", "0.005", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "cg_bobpitch", "0.002", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "cg_bobroll", "0.002", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "cg_altFireSwap", "", CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "cl_anglespeedkey", NULL, CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "in_joystick", NULL, CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "joy_threshold", NULL, CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "m_filter", NULL, CVARTYPE_PREFERENCES, FLAGS_PERSISTENT },
	{ "m_pitch", NULL, CVARTYPE_PREFERENCES, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "handicap", "100", CVARTYPE_PREFERENCES, FLAGS_NORMAL },
	{ "cl_voip", "0", CVARTYPE_PREFERENCES, FLAGS_RESTRICTED },

	// Network settings
	{ "rate", "100000", CVARTYPE_NETWORK, FLAGS_PERSISTENT },
	{ "snaps", "100", CVARTYPE_NETWORK, FLAGS_NORMAL },
	{ "cl_maxPackets", "125", CVARTYPE_NETWORK, FLAGS_NORMAL },

// Graphics settings
#ifdef USE_RENDERER_DLOPEN
	{ "cl_renderer", "opengl1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
#endif
	{ "com_maxfps", "240", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_fullscreen", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_mode", "1280x720", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_fullscreenMode", "-2", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_customWidth", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_customHeight", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_picmip", "0", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_dynamiclight", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_ext_compress_textures", "0", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_ext_texture_filter_anisotropic", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_ext_max_anisotropy", "16", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_ext_multisample", "0", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_ext_framebuffer_multisample", "0", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_textureMode", "GL_LINEAR_MIPMAP_LINEAR", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_flares", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_finish", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_swapInterval", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_fastsky", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_fastskyColor", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_gamma", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "r_ignorehwgamma", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_lodBias", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_subdivisions", NULL, CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_overBrightFactor", "1.5", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "r_mapLightingFactor", "2", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "r_mapLightingGamma", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "r_mapLightingGammaComponent", "0.75", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "r_mapLightingClampMin", "0", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "r_mapLightingClampMax", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "r_textureGamma", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "r_intensity", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "cg_fov", "85*", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT | CVAR_IMPORT_ALLOWED },
	{ "cg_aspectCorrect", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "cg_aspectCorrectCenterHud", "0", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "cmod_map_adjust_enabled", "1", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "cmod_anti_burnin", "0", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },
	{ "r_autoExposure", "0", CVARTYPE_GRAPHICS, FLAGS_PERSISTENT },

	// Sound settings
	// Don't default to OpenAL since it currently doesn't work nicely with some EF maps
	{ "s_useOpenAL", "0", CVARTYPE_SOUND, FLAGS_PERSISTENT },
	{ "s_volume", "0.6", CVARTYPE_SOUND, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "s_musicvolume", "0.6", CVARTYPE_SOUND, FLAGS_PERSISTENT | CVAR_NUMERIC },
	{ "s_noOverlap", "1", CVARTYPE_SOUND, FLAGS_PERSISTENT },
	{ "s_sdlCapture", "0", CVARTYPE_SOUND, FLAGS_PERSISTENT },

	// UI Menu Settings
	{ "ui_initialsetup", "0", CVARTYPE_MENU, FLAGS_PERSISTENT | CVAR_IMPORT_ALLOWED },
	{ "ui_browserGameType", "0", CVARTYPE_MENU, FLAGS_PERSISTENT },
	{ "ui_browserMaster", "1", CVARTYPE_MENU, FLAGS_PERSISTENT },
	{ "ui_browserShowEmpty", "1", CVARTYPE_MENU, FLAGS_PERSISTENT },
	{ "ui_browserShowFull", "1", CVARTYPE_MENU, FLAGS_PERSISTENT },
	{ "ui_browserSortKey", "4", CVARTYPE_MENU, FLAGS_PERSISTENT },
	{ "ui_browserSortKey2", "2", CVARTYPE_MENU, FLAGS_PERSISTENT },
	{ "ui_browserPlayerType", "1", CVARTYPE_MENU, FLAGS_PERSISTENT },

	// Misc cvars that untrusted VMs are allowed to modify, despite being registered somewhere in the engine
	{ "bot_challenge", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_fastchat", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_grapple", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_interbreedbots", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_interbreedchar", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_interbreedcycle", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_interbreedwrite", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_minplayers", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_nochat", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_pause", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_report", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_rocketjump", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_testrchat", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_testsolid", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "bot_thinktime", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cg_autoswitch", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cg_predictItems", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cg_stereoSeparation", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cl_paused", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "com_blood", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "dmflags", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "g_password", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "timelimit", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cl_freelook", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cl_yawspeed", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cl_pitchspeed", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
	{ "cl_run", NULL, CVARTYPE_NONE, FLAGS_NORMAL },
};

/*
=================
Cvar_RegisterSpecialCvars
=================
*/
static void Cvar_RegisterSpecialCvars( void ) {
	int i;
	for ( i = 0; i < ARRAY_LEN( specials ); ++i ) {
		const special_cvar_t *special = &specials[i];
		int flags = special->default_value ? special->flags : ( special->flags & ~CVAR_OVERRIDE_ENGINE_DEFAULT );
		localCvar_t *cvar = Cvar_EngineRegister( special->cvar_name, special->default_value, flags );
		if ( cvar ) {
			cvar->category = special->category;
		}
	}

	// Favorite server list
	for ( i = 0; i < 16; ++i ) {
		localCvar_t *cvar = Cvar_EngineRegister( va( "server%i", i + 1 ), "", FLAGS_PERSISTENT );
		if ( cvar ) {
			cvar->category = CVARTYPE_MENU;
		}
	}
}

/*
###############################################################################################

Config File Writing

###############################################################################################
*/

/*
=================
Cvar_StringRequiresQuoting

Returns qtrue if string needs quotes to avoid config file parsing issues.
=================
*/
static qboolean Cvar_StringRequiresQuoting( const char *string ) {
	if ( !*string || strchr( string, ' ' ) || strchr( string, ';' ) || Q_stristr( string, "//" ) || Q_stristr( string, "/*" ) ) {
		return qtrue;
	}
	return qfalse;
}

/*
=================
Cvar_WriteCvarsByCategory
=================
*/
static void Cvar_WriteCvarsByCategory( cvar_stream_t *stream, int category, char *prelude ) {
	int count = 0;
	localCvar_t *cvar;

	for ( cvar = cvar_first; cvar; cvar = cvar->next ) {
		// Make sure a writable value is set
		if ( !cvar->main_value.string ) {
			continue;
		}

		// Make sure we're in the right category
		if ( category != cvar->category ) {
			continue;
		}

		// Make sure the cvar is meant to be archived
		if ( cvar->engine_flags & ( CVAR_NOARCHIVE | CVAR_ROM | CVAR_INIT ) ) {
			continue;
		}
		if ( !( cvar->engine_flags & CVAR_ARCHIVE ) && !( cvar->main_flags & CVAR_ARCHIVE ) ) {
			continue;
		}

		// Don't write values that match the engine default unless they are user created (manually set by console command)
		if ( !( cvar->main_value.flags & CVAR_USER_CREATED ) && cvar->engine_default.string ) {
			const char *value = cvar->main_value.string;
			if ( cvar->engine_flags & CVAR_NUMERIC ) {
				if ( atof( value ) == atof( cvar->engine_default.string ) ) {
					continue;
				}
			} else {
				if ( !strcmp( value, cvar->engine_default.string ) ) {
					continue;
				}
			}
		}

		// Make sure origin type is valid to write
		if ( !( cvar->main_value.flags & CVAR_TRUSTED_CREATED ) ) {
			// Shouldn't happen; only trusted values should exist in main_value
			Com_Printf( "WARNING: Skipping write for cvar '%s' due to untrusted origin\n", cvar->s.name );
			continue;
		}

		// Don't write if value is excessively long or contains characters that could
		// cause problems parsing the config file
		if ( strlen( cvar->s.name ) > 256 || strlen( cvar->main_value.string ) > 512 || strchr( cvar->main_value.string, '\n' ) ||
				strchr( cvar->main_value.string, '\r' ) || strchr( cvar->main_value.string, '\"' ) ) {
			Com_Printf( "WARNING: Skipping write for cvar '%s' due to invalid string\n", cvar->s.name );
			continue;
		}

		// Place comment line above the first cvar in the section
		if ( !count ) {
			ADD_TEXT2( prelude );
		}

		// Write the set command and flags
		ADD_TEXT2( "seta" );

		// cvar name
		ADD_TEXT2( " " );
		if ( Cvar_StringRequiresQuoting( cvar->s.name ) ) {
			ADD_TEXT2( "\"" );
			ADD_TEXT2( cvar->s.name );
			ADD_TEXT2( "\"" );
		} else {
			ADD_TEXT2( cvar->s.name );
		}

		// cvar value
		ADD_TEXT2( " \"" );
		ADD_TEXT2( cvar->main_value.string );
		ADD_TEXT2( "\"" );

		// newline
		ADD_TEXT2( SYSTEM_NEWLINE );

		++count;
	}
}

/*
=================
Cvar_WriteVariables
=================
*/
void Cvar_WriteVariables( fileHandle_t f ) {
	char buffer[65536];
	cvar_stream_t stream = { buffer, 0, sizeof( buffer ), qfalse };
	buffer[0] = '\0';

	Cvar_WriteCvarsByCategory( &stream, CVARTYPE_PREFERENCES, SYSTEM_NEWLINE "// Preferences" SYSTEM_NEWLINE );
	Cvar_WriteCvarsByCategory( &stream, CVARTYPE_GRAPHICS, SYSTEM_NEWLINE "// Graphics settings" SYSTEM_NEWLINE );
	Cvar_WriteCvarsByCategory( &stream, CVARTYPE_SOUND, SYSTEM_NEWLINE "// Sound settings" SYSTEM_NEWLINE );
	Cvar_WriteCvarsByCategory( &stream, CVARTYPE_NETWORK, SYSTEM_NEWLINE "// Network settings" SYSTEM_NEWLINE );
	Cvar_WriteCvarsByCategory( &stream, CVARTYPE_NONE, SYSTEM_NEWLINE "// Other settings" SYSTEM_NEWLINE );
	Cvar_WriteCvarsByCategory( &stream, CVARTYPE_MENU, SYSTEM_NEWLINE "// Menu settings" SYSTEM_NEWLINE );

	if ( !stream.overflowed ) {
		// write to file
		FS_Write( stream.data, stream.position, f );
	}
}

/*
###############################################################################################

Initialization

###############################################################################################
*/

/*
=================
Cvar_Init
=================
*/
void Cvar_Init( void ) {
	int i;
	// setp commands are supported for compatibility with old config files
	const char *set_aliases[] = { "set", "sets", "setu", "seta", "setp", "setap", "setr", "setn" };

	cvar_debug = Cvar_Get( "cvar_debug", "0", 0 );
	sv_cheats = Cvar_Get( "sv_cheats", "1", CVAR_ROM | CVAR_SYSTEMINFO );

	Cvar_RegisterSpecialCvars();

	for ( i = 0; i < ARRAY_LEN( set_aliases ); ++i ) {
		Cmd_AddProtectableCommand( set_aliases[i], Cvar_Set_f );
		Cmd_SetCommandCompletionFunc( set_aliases[i], Cvar_CompleteCvarName );
	}
	Cmd_AddCommand( "setf", Cvar_Setf_f );
	Cmd_SetCommandCompletionFunc( "setf", Cvar_CompleteCvarName );

	Cmd_AddCommand( "print", Cvar_Print_f );
	Cmd_AddProtectableCommand( "toggle", Cvar_Toggle_f );
	Cmd_SetCommandCompletionFunc( "toggle", Cvar_CompleteCvarName );
	Cmd_AddCommand( "reset", Cvar_Reset_f );
	Cmd_SetCommandCompletionFunc( "reset", Cvar_CompleteCvarName );
	Cmd_AddCommand( "unset", Cvar_Unset_f );
	Cmd_SetCommandCompletionFunc( "unset", Cvar_CompleteCvarName );

	Cmd_AddCommand( "cvarlist", Cvar_List_f );
	Cmd_AddCommand( "cvar_restart", Cvar_Restart_f );

	Cmd_AddCommand( "var", Cvar_Var_f );
}

#endif
